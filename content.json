[{"title":"test","date":"2022-03-10T09:26:53.000Z","path":"2022/03/10/test/","text":"这是一个测试不同电脑同步的","raw":"---\ntitle: test\nauther: yuquan\nreward: false\ndate: 2022-03-10 17:26:53\ntags:\ncategories:\n---\n\n\n\n## 这是一个测试不同电脑同步的\n","tags":[]},{"title":"youtub-dl","date":"2022-01-14T14:18:11.000Z","path":"2022/01/14/youtub-dl/","text":"youtube-dl的使用命令##要配合ffmpeg的使用 #查看视频所有类型,只看不下载 youtube-dl -F [url] youtube-dl --list-formats [url] #下载指定质量的视频和音频并自动合并 youtube-dl -f [format code] [url] #下载字幕 youtube-dl --write-sub --skip-download [url] //下载单独的vtt字幕文件,而不会下载视频 youtube-dl --write-sub --all-subs [url] //下载所有语言的字幕(如果有的话) youtube-dl --write-auto-sub [url] //下载自动生成的字幕(YouTube only) #下载视频列表 youtube-dl -f [format code] [palylist_url] //这种方式可以下载制定清晰度的mp4视频 youtube-dl [playlist_url] //下载视频列表,这种方式下载的视频可能是mkv格式或者webm格式 youtube-dl -cit [playlist_url] //下载视频列表,这种方式下载的视频可能是mkv格式或者webm格式 youtube-dl --yes-playlist [url] //当链接为视频列表,则下载该列表视频,跟上面的一样,可能是mkv或者webm格式 #下载视频音频 youtube-dl -x video_URL #提取 MP3 格式的音频 youtube-dl -x --audio-format mp3 video_URL #下载整个 YouTube 播放列表 youtube-dl --extract-audio --audio-format mp3 -o \"%(title)s.%(ext)s\" playlist_URL ## 挂代理进行youtube的视频音频，-o \"%(title)s.%(ext)s\" 指定了输出文件（选项 -o），并指示它使用视频的标题和扩展名（本例为 mp3）来命名音频文件。 .\\youtube-dl.exe --proxy \"127.0.0.1:1080\" -x --audio-format mp3 -o \"%(title)s.%(ext)s\" https://youtu.be/JxJ265Az6CI","raw":"---\ntitle: youtub-dl\nauther: yuquan\nreward: false\ndate: 2022-01-14 22:18:11\ntags: 脚本\ncategories: 脚本\n---\n\n\n# youtube-dl的使用命令\n\n```bash\n##要配合ffmpeg的使用\n\n#查看视频所有类型,只看不下载\nyoutube-dl -F [url]\nyoutube-dl --list-formats [url]\n#下载指定质量的视频和音频并自动合并\nyoutube-dl -f [format code] [url]\n\n#下载字幕\nyoutube-dl --write-sub --skip-download [url] //下载单独的vtt字幕文件,而不会下载视频\n\nyoutube-dl --write-sub --all-subs [url] //下载所有语言的字幕(如果有的话)\n\nyoutube-dl --write-auto-sub [url] //下载自动生成的字幕(YouTube only)\n\n#下载视频列表\nyoutube-dl -f [format code] [palylist_url] //这种方式可以下载制定清晰度的mp4视频\n\nyoutube-dl [playlist_url] //下载视频列表,这种方式下载的视频可能是mkv格式或者webm格式\n\nyoutube-dl -cit [playlist_url] //下载视频列表,这种方式下载的视频可能是mkv格式或者webm格式\n\nyoutube-dl --yes-playlist [url] //当链接为视频列表,则下载该列表视频,跟上面的一样,可能是mkv或者webm格式\n\n#下载视频音频\n\nyoutube-dl -x video_URL\n#提取 MP3 格式的音频\nyoutube-dl -x --audio-format mp3 video_URL\n\n#下载整个 YouTube 播放列表\nyoutube-dl --extract-audio --audio-format mp3 -o \"%(title)s.%(ext)s\" playlist_URL\n\n\n\n## 挂代理进行youtube的视频音频，-o \"%(title)s.%(ext)s\" 指定了输出文件（选项 -o），并指示它使用视频的标题和扩展名（本例为 mp3）来命名音频文件。\n\n.\\youtube-dl.exe --proxy \"127.0.0.1:1080\" -x --audio-format mp3 -o \"%(title)s.%(ext)s\" https://youtu.be/JxJ265Az6CI\n\n\n\n```\n\n\n\n\n","tags":[{"name":"脚本","slug":"脚本","permalink":"https://xuyuquan0713.github.io/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"今日校园脚本","date":"2021-11-23T15:33:35.000Z","path":"2021/11/23/今日校园脚本/","text":"今日校园本脚本使用是HFUT学校，其它学校可以参考。功能：实现今日校园自动签到，使用crontab自动化执行脚本，使用server酱自动推送到微信。 import requests import json import time import datetime import pytz import base64 import argparse from Crypto.Cipher import AES from requests.sessions import session class hfuter: def __init__(self, username, password) -> None: super().__init__() self.session = requests.session() self.session.headers.update(&#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) \" \"Chrome/83.0.4103.61 Safari/537.36 Edg/83.0.478.37\", \"Accept\": \"application/json, text/plain, */*\", &#125;) self.username = username self.password = password ret = self.__login() if ret: print(\"&#123;username&#125;登录成功\".format(username=self.username)) self.logged_in = True else: print(\"&#123;username&#125;登录失败！\".format(username=self.username)) self.logged_in = False def __login(self) -> bool: def encrypt_password(text: str, key: str): \"\"\"encrypt password\"\"\" def pad(data_to_pad, block_size, style='pkcs7'): \"\"\"Apply standard padding. Args: data_to_pad (byte string): The data that needs to be padded. block_size (integer): The block boundary to use for padding. The output length is guaranteed to be a multiple of :data:`block_size`. style (string): Padding algorithm. It can be *'pkcs7'* (default), *'iso7816'* or *'x923'*. Return: byte string : the original data with the appropriate padding added at the end. \"\"\" def bchr(s): return bytes([s]) padding_len = block_size-len(data_to_pad) % block_size if style == 'pkcs7': padding = bchr(padding_len)*padding_len elif style == 'x923': padding = bchr(0)*(padding_len-1) + bchr(padding_len) elif style == 'iso7816': padding = bchr(128) + bchr(0)*(padding_len-1) else: raise ValueError(\"Unknown padding style\") return data_to_pad + padding key = key.encode('utf-8') text = text.encode('utf-8') text = pad(text, len(key), style='pkcs7') aes = AES.new(key, AES.MODE_ECB) password = aes.encrypt(text) password = base64.b64encode(password) return password ret = self.session.get(\"https://cas.hfut.edu.cn/cas/login\") # JSESSIONID ret = self.session.get('https://cas.hfut.edu.cn/cas/vercode') # check if needs Vercode millis = int(round(time.time() * 1000)) ret = self.session.get( 'https://cas.hfut.edu.cn/cas/checkInitVercode', params=&#123;'_': millis&#125;) key = ret.cookies['LOGIN_FLAVORING'] if ret.json(): # needs OCR! will be done later. print('需验证码，目前该功能此脚本未支持') return False else: print('无需验证码') # 加密密码 password = encrypt_password(self.password, key) # 先get ret = self.session.get( 'https://cas.hfut.edu.cn/cas/policy/checkUserIdenty', params=&#123;'_': millis+1, 'username': self.username, 'password': password&#125;) ret = ret.json() # 判断是否成功 if ret['msg'] != 'success' and not ret['data']['authFlag']: return False if ret['data']['mailRequired'] or ret['data']['phoneRequired']: print(\"你需要先进行手机或者邮箱的认证，请在PC上打开cas.hfut.edu.cn页面进行登录之后才可使用此脚本\") return False # 然后post self.session.headers.update( &#123;\"Content-Type\": \"application/x-www-form-urlencoded\"&#125;) ret = self.session.post( 'https://cas.hfut.edu.cn/cas/login', data=&#123; 'username': self.username, 'capcha': \"\", 'execution': \"e1s1\", '_eventId': \"submit\", 'password': password, 'geolocation': \"\", 'submit': \"登录\" &#125;) self.session.headers.pop(\"Content-Type\") if ret.text.find(\"cas协议登录成功跳转页面\") != -1: return True else: return False def basic_infomation(self): if not self.logged_in: return &#123;&#125; self.session.get( \"http://stu.hfut.edu.cn/xsfw/sys/swmjbxxapp/*default/index.do\") self.session.headers.update(&#123; \"Content-Type\": \"application/x-www-form-urlencoded\", \"X-Requested-With\": \"XMLHttpRequest\" &#125;) self.session.post( \"http://stu.hfut.edu.cn/xsfw/sys/emapfunauth/welcomeAutoIndex.do\" ) self.session.headers.pop(\"Content-Type\") self.session.headers.pop(\"X-Requested-With\") ret = self.session.get( \"http://stu.hfut.edu.cn/xsfw/sys/emapfunauth/casValidate.do\", params=&#123; 'service': '/xsfw/sys/swmjbxxapp/*default/index.do' &#125; ) self.session.headers.update(&#123;\"X-Requested-With\": \"XMLHttpRequest\"&#125;) self.session.headers.update( &#123;\"Referer\": \"http://stu.hfut.edu.cn/xsfw/sys/swmjbxxapp/*default/index.do\"&#125;) ret = self.session.get( \"http://stu.hfut.edu.cn/xsfw/sys/emappagelog/config/swmjbxxapp.do\") self.session.headers.pop(\"X-Requested-With\") config_data = &#123;\"APPID\": \"4930169432823497\", \"APPNAME\": \"swmjbxxapp\"&#125; self.session.headers.update( &#123;\"Content-Type\": \"application/x-www-form-urlencoded\"&#125;) ret = self.session.post( \"http://stu.hfut.edu.cn/xsfw/sys/swpubapp/MobileCommon/getSelRoleConfig.do\", data=&#123;\"data\": json.dumps(config_data)&#125; ).json() if ret[\"code\"] != \"0\": print(ret[\"msg\"]) return &#123;&#125; ret = self.session.post( \"http://stu.hfut.edu.cn/xsfw/sys/swpubapp/MobileCommon/getMenuInfo.do\", data=&#123;\"data\": json.dumps(config_data)&#125; ).json() if ret[\"code\"] != \"0\": print(ret[\"msg\"]) return &#123;&#125; self.session.headers.pop(\"Content-Type\") info = self.session.get( \"http://stu.hfut.edu.cn/xsfw/sys/swmjbxxapp/StudentBasicInfo/initPageConfig.do\", params=&#123;\"data\": \"&#123;&#125;\"&#125;).json() self.session.headers.pop(\"Referer\") return info['data'] def daily_checkin(self, address: str) -> bool: if not self.logged_in: return False today = datetime.datetime.now( tz=pytz.timezone('Asia/Shanghai')).timetuple()[:3] self.session.get( \"http://stu.hfut.edu.cn/xsfw/sys/swmxsyqxxsjapp/*default/index.do\") self.session.headers.update(&#123; \"Content-Type\": \"application/x-www-form-urlencoded\", \"X-Requested-With\": \"XMLHttpRequest\" &#125;) self.session.post( \"http://stu.hfut.edu.cn/xsfw/sys/emapfunauth/welcomeAutoIndex.do\" ) self.session.headers.pop(\"Content-Type\") self.session.headers.pop(\"X-Requested-With\") ret = self.session.get( \"http://stu.hfut.edu.cn/xsfw/sys/emapfunauth/casValidate.do\", params=&#123; 'service': '/xsfw/sys/swmjbxxapp/*default/index.do' &#125; ) self.session.headers.update(&#123;\"X-Requested-With\": \"XMLHttpRequest\"&#125;) self.session.headers.update( &#123;\"Referer\": \"http://stu.hfut.edu.cn/xsfw/sys/swmjbxxapp/*default/index.do\"&#125;) ret = self.session.get( \"http://stu.hfut.edu.cn/xsfw/sys/emappagelog/config/swmxsyqxxsjapp.do\") self.session.headers.pop(\"X-Requested-With\") config_data = &#123;\"APPID\": \"5811260348942403\", \"APPNAME\": \"swmxsyqxxsjapp\"&#125; self.session.headers.update( &#123;\"Content-Type\": \"application/x-www-form-urlencoded\"&#125;) ret = self.session.post( \"http://stu.hfut.edu.cn/xsfw/sys/swpubapp/MobileCommon/getSelRoleConfig.do\", data=&#123;\"data\": json.dumps(config_data)&#125; ).json() if ret[\"code\"] != \"0\": print(ret[\"msg\"]) return False ret = self.session.post( \"http://stu.hfut.edu.cn/xsfw/sys/swpubapp/MobileCommon/getMenuInfo.do\", data=&#123;\"data\": json.dumps(config_data)&#125; ).json() if ret[\"code\"] != \"0\": print(ret[\"msg\"]) return False self.session.headers.pop(\"Content-Type\") info = self.session.get( \"http://stu.hfut.edu.cn/xsfw/sys/swmxsyqxxsjapp/modules/mrbpa/getSetting.do\", data=&#123;\"data\": \"&#123;&#125;\"&#125; ).json() start_time = \"%04d-%02d-%02d \" % today + \\ info['data']['DZ_TBKSSJ'] + \" +0800\" start_time = datetime.datetime.strptime( start_time, \"%Y-%m-%d %H:%M:%S %z\") end_time = \"%04d-%02d-%02d \" % today + \\ info['data']['DZ_TBJSSJ'] + \" +0800\" end_time = datetime.datetime.strptime(end_time, \"%Y-%m-%d %H:%M:%S %z\") now_time = datetime.datetime.now(tz=pytz.timezone('Asia/Shanghai')) print(\"打卡起始时间:\", start_time) print(\"打卡结束时间:\", end_time) print(\" 现在时间:\", now_time) if start_time &lt; now_time and now_time &lt; end_time: print(\"在打卡时间内\") else: print(\"不在打卡时间内\") return False self.session.headers.update( &#123;\"Content-Type\": \"application/x-www-form-urlencoded\"&#125;) last_form = self.session.post( \"http://stu.hfut.edu.cn/xsfw/sys/swmxsyqxxsjapp/modules/mrbpa/getStuXx.do\", data=&#123;\"data\": json.dumps(&#123;\"TBSJ\": \"%.2d-%.2d-%.2d\" % today&#125;)&#125; ).json() if last_form['code'] != \"0\": return False new_form = last_form['data'] new_form.update(&#123; \"DZ_SFSB\": \"1\", \"GCKSRQ\": \"\", \"GCJSRQ\": \"\", \"DFHTJHBSJ\": \"\", \"DZ_TBDZ\": address, \"BY1\": \"1\", \"TBSJ\": \"%.2d-%.2d-%.2d\" % today &#125;) ret = self.session.post( \"http://stu.hfut.edu.cn/xsfw/sys/swmxsyqxxsjapp/modules/mrbpa/saveStuXx.do\", data=&#123;\"data\": json.dumps(new_form)&#125; ).json() self.session.headers.pop(\"Content-Type\") self.session.headers.pop(\"Referer\") return ret['code'] == \"0\" # An example code demonstrating how to use the interfaces. # actually, it was already usable. if __name__ == \"__main__\": arg_parser = argparse.ArgumentParser() arg_parser.add_argument('username', type=str, help=\"学工号\") arg_parser.add_argument('password', type=str, help=\"密码，默认为身份证后6位\") arg_parser.add_argument('address', type=str, help=\"签到地址\") args = arg_parser.parse_args() stu = hfuter(username=args.username, password=args.password) if stu.daily_checkin(args.address): sckey = 'key'#在发送消息页面可以找到 #text为推送的title,desp为推送的描述 url = 'https://sc.ftqq.com/%s.send?text=推送主题&amp;desp=内容'%sckey requests.get(url) print(\"签到成功~\") else: print(\"签到失败！\") 使用方法执行 python3 学号 密码 地点。自动化部署： #启动crontab sudo service cron start #编辑crontab文件 crontab -e * * * * * command 分 时 天 月 周 命令 如：15 15 × × × python3 学号 密码 地点 #更改编辑器 sudo select-editor #查看定时任务 crontab -l #重启任务 sudo service cron restart","raw":"---\ntitle: 今日校园脚本\nauther: yuquan\nreward: false\ndate: 2021-11-23 23:33:35\ntags: 其他\ncategories: 其他 \n\n---\n\n# 今日校园\n\n本脚本使用是HFUT学校，其它学校可以参考。\n功能：\n实现今日校园自动签到，使用`crontab`自动化执行脚本，使用`server`酱自动推送到微信。\n\n<!--more-->\n\n```python\nimport requests\nimport json\nimport time\nimport datetime\nimport pytz\nimport base64\nimport argparse\nfrom Crypto.Cipher import AES\nfrom requests.sessions import session\n\n\nclass hfuter:\n    def __init__(self, username, password) -> None:\n        super().__init__()\n\n        self.session = requests.session()\n        self.session.headers.update({\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) \"\n            \"Chrome/83.0.4103.61 Safari/537.36 Edg/83.0.478.37\",\n            \"Accept\": \"application/json, text/plain, */*\",\n        })\n\n        self.username = username\n        self.password = password\n\n        ret = self.__login()\n        if ret:\n            print(\"{username}登录成功\".format(username=self.username))\n            self.logged_in = True\n        else:\n            print(\"{username}登录失败！\".format(username=self.username))\n            self.logged_in = False\n\n    def __login(self) -> bool:\n        def encrypt_password(text: str, key: str):\n            \"\"\"encrypt password\"\"\"\n            def pad(data_to_pad, block_size, style='pkcs7'):\n                \"\"\"Apply standard padding.\n\n                Args:\n                data_to_pad (byte string):\n                    The data that needs to be padded.\n                block_size (integer):\n                    The block boundary to use for padding. The output length is guaranteed\n                    to be a multiple of :data:`block_size`.\n                style (string):\n                    Padding algorithm. It can be *'pkcs7'* (default), *'iso7816'* or *'x923'*.\n\n                Return:\n                byte string : the original data with the appropriate padding added at the end.\n                \"\"\"\n                def bchr(s):\n                    return bytes([s])\n\n                padding_len = block_size-len(data_to_pad) % block_size\n                if style == 'pkcs7':\n                    padding = bchr(padding_len)*padding_len\n                elif style == 'x923':\n                    padding = bchr(0)*(padding_len-1) + bchr(padding_len)\n                elif style == 'iso7816':\n                    padding = bchr(128) + bchr(0)*(padding_len-1)\n                else:\n                    raise ValueError(\"Unknown padding style\")\n                return data_to_pad + padding\n            key = key.encode('utf-8')\n            text = text.encode('utf-8')\n\n            text = pad(text, len(key), style='pkcs7')\n\n            aes = AES.new(key, AES.MODE_ECB)\n            password = aes.encrypt(text)\n            password = base64.b64encode(password)\n            return password\n\n        ret = self.session.get(\"https://cas.hfut.edu.cn/cas/login\")\n        # JSESSIONID\n        ret = self.session.get('https://cas.hfut.edu.cn/cas/vercode')\n        # check if needs Vercode\n        millis = int(round(time.time() * 1000))\n        ret = self.session.get(\n            'https://cas.hfut.edu.cn/cas/checkInitVercode', params={'_': millis})\n        key = ret.cookies['LOGIN_FLAVORING']\n\n        if ret.json():\n            # needs OCR! will be done later.\n            print('需验证码，目前该功能此脚本未支持')\n            return False\n        else:\n            print('无需验证码')\n\n        # 加密密码\n        password = encrypt_password(self.password, key)\n\n        # 先get\n        ret = self.session.get(\n            'https://cas.hfut.edu.cn/cas/policy/checkUserIdenty',\n            params={'_': millis+1, 'username': self.username, 'password': password})\n\n        ret = ret.json()\n\n        # 判断是否成功\n        if ret['msg'] != 'success' and not ret['data']['authFlag']:\n            return False\n\n        if ret['data']['mailRequired'] or ret['data']['phoneRequired']:\n            print(\"你需要先进行手机或者邮箱的认证，请在PC上打开cas.hfut.edu.cn页面进行登录之后才可使用此脚本\")\n            return False\n\n        # 然后post\n        self.session.headers.update(\n            {\"Content-Type\": \"application/x-www-form-urlencoded\"})\n        ret = self.session.post(\n            'https://cas.hfut.edu.cn/cas/login',\n            data={\n                'username': self.username,\n                'capcha': \"\",\n                'execution': \"e1s1\",\n                '_eventId': \"submit\",\n                'password': password,\n                'geolocation': \"\",\n                'submit': \"登录\"\n            })\n        self.session.headers.pop(\"Content-Type\")\n\n        if ret.text.find(\"cas协议登录成功跳转页面\") != -1:\n            return True\n        else:\n            return False\n\n    def basic_infomation(self):\n        if not self.logged_in:\n            return {}\n\n        self.session.get(\n            \"http://stu.hfut.edu.cn/xsfw/sys/swmjbxxapp/*default/index.do\")\n\n        self.session.headers.update({\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"X-Requested-With\": \"XMLHttpRequest\"\n        })\n        self.session.post(\n            \"http://stu.hfut.edu.cn/xsfw/sys/emapfunauth/welcomeAutoIndex.do\"\n        )\n        self.session.headers.pop(\"Content-Type\")\n        self.session.headers.pop(\"X-Requested-With\")\n\n        ret = self.session.get(\n            \"http://stu.hfut.edu.cn/xsfw/sys/emapfunauth/casValidate.do\",\n            params={\n                'service': '/xsfw/sys/swmjbxxapp/*default/index.do'\n            }\n        )\n\n        self.session.headers.update({\"X-Requested-With\": \"XMLHttpRequest\"})\n        self.session.headers.update(\n            {\"Referer\": \"http://stu.hfut.edu.cn/xsfw/sys/swmjbxxapp/*default/index.do\"})\n        ret = self.session.get(\n            \"http://stu.hfut.edu.cn/xsfw/sys/emappagelog/config/swmjbxxapp.do\")\n        self.session.headers.pop(\"X-Requested-With\")\n\n        config_data = {\"APPID\": \"4930169432823497\", \"APPNAME\": \"swmjbxxapp\"}\n        self.session.headers.update(\n            {\"Content-Type\": \"application/x-www-form-urlencoded\"})\n        ret = self.session.post(\n            \"http://stu.hfut.edu.cn/xsfw/sys/swpubapp/MobileCommon/getSelRoleConfig.do\",\n            data={\"data\": json.dumps(config_data)}\n        ).json()\n        if ret[\"code\"] != \"0\":\n            print(ret[\"msg\"])\n            return {}\n        ret = self.session.post(\n            \"http://stu.hfut.edu.cn/xsfw/sys/swpubapp/MobileCommon/getMenuInfo.do\",\n            data={\"data\": json.dumps(config_data)}\n        ).json()\n        if ret[\"code\"] != \"0\":\n            print(ret[\"msg\"])\n            return {}\n        self.session.headers.pop(\"Content-Type\")\n\n        info = self.session.get(\n            \"http://stu.hfut.edu.cn/xsfw/sys/swmjbxxapp/StudentBasicInfo/initPageConfig.do\", params={\"data\": \"{}\"}).json()\n        self.session.headers.pop(\"Referer\")\n\n        return info['data']\n\n    def daily_checkin(self, address: str) -> bool:\n        if not self.logged_in:\n            return False\n\n        today = datetime.datetime.now(\n            tz=pytz.timezone('Asia/Shanghai')).timetuple()[:3]\n        self.session.get(\n            \"http://stu.hfut.edu.cn/xsfw/sys/swmxsyqxxsjapp/*default/index.do\")\n\n        self.session.headers.update({\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"X-Requested-With\": \"XMLHttpRequest\"\n        })\n        self.session.post(\n            \"http://stu.hfut.edu.cn/xsfw/sys/emapfunauth/welcomeAutoIndex.do\"\n        )\n        self.session.headers.pop(\"Content-Type\")\n        self.session.headers.pop(\"X-Requested-With\")\n\n        ret = self.session.get(\n            \"http://stu.hfut.edu.cn/xsfw/sys/emapfunauth/casValidate.do\",\n            params={\n                'service': '/xsfw/sys/swmjbxxapp/*default/index.do'\n            }\n        )\n\n        self.session.headers.update({\"X-Requested-With\": \"XMLHttpRequest\"})\n        self.session.headers.update(\n            {\"Referer\": \"http://stu.hfut.edu.cn/xsfw/sys/swmjbxxapp/*default/index.do\"})\n        ret = self.session.get(\n            \"http://stu.hfut.edu.cn/xsfw/sys/emappagelog/config/swmxsyqxxsjapp.do\")\n        self.session.headers.pop(\"X-Requested-With\")\n\n        config_data = {\"APPID\": \"5811260348942403\",\n                       \"APPNAME\": \"swmxsyqxxsjapp\"}\n        self.session.headers.update(\n            {\"Content-Type\": \"application/x-www-form-urlencoded\"})\n        ret = self.session.post(\n            \"http://stu.hfut.edu.cn/xsfw/sys/swpubapp/MobileCommon/getSelRoleConfig.do\",\n            data={\"data\": json.dumps(config_data)}\n        ).json()\n        if ret[\"code\"] != \"0\":\n            print(ret[\"msg\"])\n            return False\n        ret = self.session.post(\n            \"http://stu.hfut.edu.cn/xsfw/sys/swpubapp/MobileCommon/getMenuInfo.do\",\n            data={\"data\": json.dumps(config_data)}\n        ).json()\n        if ret[\"code\"] != \"0\":\n            print(ret[\"msg\"])\n            return False\n        self.session.headers.pop(\"Content-Type\")\n\n        info = self.session.get(\n            \"http://stu.hfut.edu.cn/xsfw/sys/swmxsyqxxsjapp/modules/mrbpa/getSetting.do\",\n            data={\"data\": \"{}\"}\n        ).json()\n\n        start_time = \"%04d-%02d-%02d \" % today + \\\n            info['data']['DZ_TBKSSJ'] + \" +0800\"\n        start_time = datetime.datetime.strptime(\n            start_time, \"%Y-%m-%d %H:%M:%S %z\")\n        end_time = \"%04d-%02d-%02d \" % today + \\\n            info['data']['DZ_TBJSSJ'] + \" +0800\"\n        end_time = datetime.datetime.strptime(end_time, \"%Y-%m-%d %H:%M:%S %z\")\n        now_time = datetime.datetime.now(tz=pytz.timezone('Asia/Shanghai'))\n\n        print(\"打卡起始时间:\", start_time)\n        print(\"打卡结束时间:\", end_time)\n        print(\"　　现在时间:\", now_time)\n        if start_time < now_time and now_time < end_time:\n            print(\"在打卡时间内\")\n        else:\n            print(\"不在打卡时间内\")\n            return False\n\n        self.session.headers.update(\n            {\"Content-Type\": \"application/x-www-form-urlencoded\"})\n        last_form = self.session.post(\n            \"http://stu.hfut.edu.cn/xsfw/sys/swmxsyqxxsjapp/modules/mrbpa/getStuXx.do\",\n            data={\"data\": json.dumps({\"TBSJ\": \"%.2d-%.2d-%.2d\" % today})}\n        ).json()\n        if last_form['code'] != \"0\":\n            return False\n\n        new_form = last_form['data']\n        new_form.update({\n            \"DZ_SFSB\": \"1\",\n            \"GCKSRQ\": \"\",\n            \"GCJSRQ\": \"\",\n            \"DFHTJHBSJ\": \"\",\n            \"DZ_TBDZ\": address,\n            \"BY1\": \"1\",\n            \"TBSJ\": \"%.2d-%.2d-%.2d\" % today\n        })\n\n        ret = self.session.post(\n            \"http://stu.hfut.edu.cn/xsfw/sys/swmxsyqxxsjapp/modules/mrbpa/saveStuXx.do\",\n            data={\"data\": json.dumps(new_form)}\n        ).json()\n\n        self.session.headers.pop(\"Content-Type\")\n        self.session.headers.pop(\"Referer\")\n        return ret['code'] == \"0\"\n\n\n# An example code demonstrating how to use the interfaces.\n# actually, it was already usable.\nif __name__ == \"__main__\":\n    arg_parser = argparse.ArgumentParser()\n    arg_parser.add_argument('username', type=str, help=\"学工号\")\n    arg_parser.add_argument('password', type=str, help=\"密码，默认为身份证后6位\")\n    arg_parser.add_argument('address', type=str, help=\"签到地址\")\n    args = arg_parser.parse_args()\n\n    stu = hfuter(username=args.username, password=args.password)\n    if stu.daily_checkin(args.address):\n        sckey = 'key'#在发送消息页面可以找到\n        #text为推送的title,desp为推送的描述\n        url = 'https://sc.ftqq.com/%s.send?text=推送主题&desp=内容'%sckey\n        requests.get(url)\n        print(\"签到成功~\")\n    else:\n        print(\"签到失败！\")\n\n```\n\n使用方法执行 `python3 学号 密码 地点`。\n自动化部署：\n\n```python\n#启动crontab\nsudo service cron start\n#编辑crontab文件\ncrontab -e\n*  *  * *  *   command\n分 时 天 月 周   命令\n如：15 15 × × ×  python3 学号 密码 地点\n#更改编辑器\nsudo select-editor\n#查看定时任务\ncrontab -l\n#重启任务\nsudo service cron restart\n\n\n```\n","tags":[{"name":"其他","slug":"其他","permalink":"https://xuyuquan0713.github.io/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"linux-and-vim","date":"2021-07-03T09:31:02.000Z","path":"2021/07/03/linux-and-vim/","text":"linux下的vim的使用 1、zsh终端的安装和使用安装： sudo apt install zsh 安装oh-my-zsh sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 或者 sh -c &quot;$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot; 配置文件： vim ./zshrc可以在ZSH_THEME=”ys”配置相应的主题，在官网上可以找到相应的主题。然后终端执行source ~/.zshrc oh-my-zsh 的自带插件都储存在~/.oh-my-zsh/plugins目录中，如果你希望安装一个插件，可以在 ~/.zshrc的 plugins=(xxx, xxx, …) 这一行里加入插件名称. 如果你需要安装第三方插件和主题，你可以在 “~/.zshrc” 的某一行（比如末尾）加入 source /path/to/plugin,根据自己的插件输入目录。 2、vim插件vim-plug的安装和使用安装： mkdir -p ~/.vim/autoload/ cp plug.vim ~/.vim/autoload/plug.vim 插件的添加和使用：编辑~/.vimrc文件中的内容，比如安装“lightline.vim” 插件 call plug#begin('~/.vim/plugged') Plug 'itchyny/lightline.vim' call plug#end() 运行命令重新加载： :source ~/.vimrc 插件的安装和卸载： 打开 vim 使用命令 : :PlugInstall 你也可以使用以下命令，指定安装特定的插件： :PlugInstall gist-vim 打开 vim 使用命令卸载： :PlugClean 更新插件： 使用以下命令，可以更新vim-plug插件自身： :PlugUpgrade 使用以下命令，可以批量更新所有已安装的插件： :PlugUpdate 使用以下命令，可以查看当前已安装插件的状态信息： :PlugStatus Vim常用的插件推荐 Vim操作的使用： 1、Vim键盘 2、Vim命令图解 3、Vim使用 3、Tmux的安装和使用==介绍：== tmux 是一款优秀的终端复用工具（terminal multiplexer），是常用的开发工具，使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机。使用手册 ==关于会话，窗口，进程:== 命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称 “窗口”），在里面输入命令。 用户与计算机的这种临时的交互，称为一次 “会话”（session） 。 会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。 一个典型的例子就是，SSH 登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。 为了解决这个问题，会话与窗口可以 “解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话 “绑定” 其他窗口。 tmux 就是会话与窗口的 “解绑” 工具，将它们彻底分离。 （1）它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。 （2）它可以让新窗口 “接入” 已经存在的会话。 （3）它允许每个会话有多个连接窗口，因此可以多人实时共享会话。 （4）它还支持窗口任意的垂直和水平拆分。 类似的终端复用器还有 GNU Screen。tmux 与它功能相似，但是更易用，也更强大。 ==tmux概念== 使用 Tmux 的时候不用去背指令，所有的指令都可以在 .tmux.conf 配置文件中绑定自己顺手的快捷键，也可以配置开启鼠标。 在Tmux逻辑中，需要分清楚Server &gt; Session &gt; Window &gt; Pane这个大小和层级顺序是极其重要的，直接关系到工作效率： Server：是整个tmux的后台服务。有时候更改配置不生效，就要使用tmux kill-server来重启tmux。 Session：是tmux的所有会话。我之前就错把这个session当成窗口用，造成了很多不便里。一般只要保存一个session就足够了。 Window：相当于一个工作区，包含很多分屏，可以针对每种任务分一个Window。如下载一个Window，编程一个window。 Pane：是在Window里面的小分屏。最常用也最好用 了解了这个逻辑后，整个Tmux的使用和配置也就清晰了。 详细的使用书籍 使用操作 4、linux快捷键使用快捷键：","raw":"---\ntitle: linux-and-vim\nauther: yuquan\nreward: false\ndate: 2021-07-03 17:31:02\ntags: vim\ncategories: vim\n---\n\n# linux下的vim的使用\n\n![](https://gitee.com/xu-yuquan/picture-markdown/raw/master/tmux.png)\n\n\n\n<!--more-->\n\n## 1、zsh终端的安装和使用\n\n**安装：**\n\n`sudo apt install zsh`\n\n**安装[oh-my-zsh](https://ohmyz.sh/)**\n\n`sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"`\n\n或者\n\n`sh -c \"$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)\"`\n\n**配置文件：**\n\n`vim ./zshrc`可以在ZSH_THEME=\"ys\"配置相应的主题，在官网上可以找到相应的主题。然后终端执行`source ~/.zshrc`\n\noh-my-zsh 的自带插件都储存在~/.oh-my-zsh/plugins目录中，如果你希望安装一个插件，可以在 ~/.zshrc的 plugins=(xxx, xxx, ...) 这一行里加入插件名称.\n\n如果你需要安装第三方插件和主题，你可以在 \"~/.zshrc\" 的某一行（比如末尾）加入 source /path/to/plugin,根据自己的插件输入目录。\n\n## 2、vim插件[vim-plug](https://github.com/junegunn/vim-plug)的安装和使用\n\n**安装：**\n\n`mkdir -p  ~/.vim/autoload/`\n\n`cp plug.vim  ~/.vim/autoload/plug.vim`\n\n**插件的添加和使用：**\n编辑~/.vimrc文件中的内容，比如安装“lightline.vim” 插件\n\n```bash\ncall plug#begin('~/.vim/plugged')\nPlug 'itchyny/lightline.vim'\ncall plug#end()\n```\n\n**运行命令重新加载：**\n\n`:source ~/.vimrc`\n\n插件的安装和卸载：\n\n> ```bash\n> 打开 vim 使用命令 :\n> :PlugInstall\n> 你也可以使用以下命令，指定安装特定的插件：\n> :PlugInstall gist-vim \n> 打开 vim 使用命令卸载：\n> :PlugClean\n> ```\n\n**更新插件：**\n\n使用以下命令，可以更新vim-plug插件自身：\n\n`:PlugUpgrade`\n\n使用以下命令，可以批量更新所有已安装的插件：\n\n`:PlugUpdate`\n\n使用以下命令，可以查看当前已安装插件的状态信息：\n\n`:PlugStatus`\n\n[Vim常用的插件推荐](https://zhuanlan.zhihu.com/p/84954261)\n\n**Vim操作的使用：**\n\n1、Vim键盘\n\n![](https://gitee.com/xu-yuquan/picture-markdown/raw/master/vi-vim-cheat-sheet-sch.gif)\n\n2、Vim命令图解\n\n![](https://gitee.com/xu-yuquan/picture-markdown/raw/master/vim-cheat-sheet-full.png)\n\n3、Vim使用\n\n![](https://gitee.com/xu-yuquan/picture-markdown/raw/master/vim-cheat-sheet-cn.png)\n\n![](https://gitee.com/xu-yuquan/picture-markdown/raw/master/vim_cheat_sheet_for_programmers_screen.png)\n\n## 3、Tmux的安装和使用\n\n==**介绍：**==\n\n![](https://gitee.com/xu-yuquan/picture-markdown/raw/master/tmux.png)\n\ntmux 是一款优秀的终端复用工具（terminal multiplexer），是常用的开发工具，使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机。[使用手册](http://louiszhai.github.io/2017/09/30/tmux/#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)\n\n==**关于会话，窗口，进程:**==\n\n命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称 “窗口”），在里面输入命令。 用户与计算机的这种临时的交互，称为一次 “会话”（session） 。\n\n会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。\n\n一个典型的例子就是，SSH 登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。\n\n为了解决这个问题，会话与窗口可以 “解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话 “绑定” 其他窗口。\n\ntmux 就是会话与窗口的 “解绑” 工具，将它们彻底分离。\n\n（1）它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。\n\n（2）它可以让新窗口 “接入” 已经存在的会话。\n\n（3）它允许每个会话有多个连接窗口，因此可以多人实时共享会话。\n\n（4）它还支持窗口任意的垂直和水平拆分。\n\n类似的终端复用器还有 GNU Screen。tmux 与它功能相似，但是更易用，也更强大。\n\n![](https://gitee.com/xu-yuquan/picture-markdown/raw/master/tmux-1.png)\n\n==**tmux概念**==\n\n使用 Tmux 的时候不用去背指令，所有的指令都可以在 `.tmux.conf` 配置文件中绑定自己顺手的快捷键，也可以配置开启鼠标。\n\n在Tmux逻辑中，需要分清楚Server > Session > Window > Pane这个大小和层级顺序是极其重要的，直接关系到工作效率：\n\n- Server：是整个tmux的后台服务。有时候更改配置不生效，就要使用tmux kill-server来重启tmux。\n- Session：是tmux的所有会话。我之前就错把这个session当成窗口用，造成了很多不便里。一般只要保存一个session就足够了。\n- Window：相当于一个工作区，包含很多分屏，可以针对每种任务分一个Window。如下载一个Window，编程一个window。\n- Pane：是在Window里面的小分屏。最常用也最好用\n\n了解了这个逻辑后，整个Tmux的使用和配置也就清晰了。\n\n![](https://gitee.com/xu-yuquan/picture-markdown/raw/master/tmux1.png)\n\n[详细的使用书籍](https://pityonline.gitbooks.io/tmux-productive-mouse-free-development_zh/content/index.html)\n\n[使用操作](https://www.freeaihub.com/article/tmux.html)\n\n\n## 4、linux快捷键使用\n\n**快捷键：**\n\n![](https://gitee.com/xu-yuquan/picture-markdown/raw/master/linux_common_commands2.jpg)\n\n![](https://gitee.com/xu-yuquan/picture-markdown/raw/master/Linux-Command-Line-Guide.png)\n","tags":[{"name":"vim","slug":"vim","permalink":"https://xuyuquan0713.github.io/tags/vim/"}]},{"title":"Jupyter Notebook 的快捷键","date":"2021-05-10T07:29:35.000Z","path":"2021/05/10/Jupyter-Notebook-的快捷键/","text":"Jupyter Notebook 的快捷键Jupyter Notebook 有两种键盘输入模式。 使用前需要进行安装： pip install jupyter (前提是你已经安装好Python,并将python添加到环境解释器中) 安装完成之后，因为python已经添加至环境变量中，所以直接使用 ==jupyter notebook==即可启动，如果你想要打开ipynb结尾的文件，直接在cmd控制台将用cd切换到ipynb结尾的文件所在的目录即可！ ==Jupyter Notebook== 有两种键盘输入模式。编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。命令模式，键盘输入运行程序命令；这时的单元框线是灰色。 命令模式 (按键 Esc 开启) Enter : 转入编辑模式 Shift-Enter : 运行本单元，选中下个单元 Ctrl-Enter : 运行本单元 Alt-Enter : 运行本单元，在其下插入新单元 Y : 单元转入代码状态 M :单元转入markdown状态 R : 单元转入raw状态 1 : 设定 1 级标题 2 : 设定 2 级标题 3 : 设定 3 级标题 4 : 设定 4 级标题 5 : 设定 5 级标题 6 : 设定 6 级标题 Up : 选中上方单元 K : 选中上方单元 Down : 选中下方单元 J : 选中下方单元 Shift-K : 扩大选中上方单元 Shift-J : 扩大选中下方单元 A : 在上方插入新单元 B : 在下方插入新单元 X : 剪切选中的单元 C : 复制选中的单元 Shift-V : 粘贴到上方单元 V : 粘贴到下方单元 Z : 恢复删除的最后一个单元 D,D : 删除选中的单元 Shift-M : 合并选中的单元 Ctrl-S : 文件存盘 S : 文件存盘 L : 转换行号 O : 转换输出 Shift-O : 转换输出滚动 Esc : 关闭页面 Q : 关闭页面 H : 显示快捷键帮助 I,I : 中断Notebook内核 0,0 : 重启Notebook内核 Shift : 忽略 Shift-Space : 向上滚动 Space : 向下滚动 编辑模式 ( Enter 键启动) Tab : 代码补全或缩进 Shift-Tab : 提示 Ctrl-] : 缩进 Ctrl-[ : 解除缩进 Ctrl-A : 全选 Ctrl-Z : 复原 Ctrl-Shift-Z : 再做 Ctrl-Y : 再做 Ctrl-Home : 跳到单元开头 Ctrl-Up : 跳到单元开头 Ctrl-End : 跳到单元末尾 Ctrl-Down : 跳到单元末尾 Ctrl-Left : 跳到左边一个字首 Ctrl-Right : 跳到右边一个字首 Ctrl-Backspace : 删除前面一个字 Ctrl-Delete : 删除后面一个字 Esc : 进入命令模式 Ctrl-M : 进入命令模式 Shift-Enter : 运行本单元，选中下一单元 Ctrl-Enter : 运行本单元 Alt-Enter : 运行本单元，在下面插入一单元 Ctrl-Shift– : 分割单元 Ctrl-Shift-Subtract : 分割单元 Ctrl-S : 文件存盘 Shift : 忽略 Up : 光标上移或转入上一单元 Down :光标下移或转入下一单元","raw":"---\ntitle: Jupyter Notebook 的快捷键\nauther: yuquan\nreward: false\ndate: 2021-05-10 15:29:35\ntags: Python\ncategories: 快捷键\n---\n\n# Jupyter Notebook 的快捷键\n\n**Jupyter Notebook 有两种键盘输入模式。**\n\n<!--more-->\n\n**使用前需要进行安装：**\n\n`pip install jupyter`  **(前提是你已经安装好Python,并将python添加到环境解释器中)**\n\n**安装完成之后，因为python已经添加至环境变量中，所以直接使用 ==jupyter notebook==即可启动，如果你想要打开ipynb结尾的文件，直接在cmd控制台将用cd切换到ipynb结尾的文件所在的目录即可！**\n\n**==Jupyter Notebook== 有两种键盘输入模式。编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。命令模式，键盘输入运行程序命令；这时的单元框线是灰色。**\n\n### **命令模式 (按键 Esc 开启)**\n\n-   **Enter** : 转入编辑模式\n-   **Shift-Enter** : 运行本单元，选中下个单元\n-   **Ctrl-Enter** : 运行本单元\n-   **Alt-Enter** : 运行本单元，在其下插入新单元\n-   **Y** : 单元转入代码状态\n-   **M** :单元转入markdown状态\n-   **R** : 单元转入raw状态\n-   **1** : 设定 1 级标题\n-   **2** : 设定 2 级标题\n-   **3** : 设定 3 级标题\n-   **4** : 设定 4 级标题\n-   **5** : 设定 5 级标题\n-   **6** : 设定 6 级标题\n-   **Up** : 选中上方单元\n-   **K** : 选中上方单元\n-   **Down** : 选中下方单元\n-   **J** : 选中下方单元\n-   **Shift-K** : 扩大选中上方单元\n-   **Shift-J** : 扩大选中下方单元\n-   **A** : 在上方插入新单元\n-   **B** : 在下方插入新单元\n-   **X** : 剪切选中的单元\n-   **C** : 复制选中的单元\n-   **Shift-V** : 粘贴到上方单元\n-   **V** : 粘贴到下方单元\n-   **Z** : 恢复删除的最后一个单元\n-   **D,D** : 删除选中的单元\n-   **Shift-M** : 合并选中的单元\n-   **Ctrl-S** : 文件存盘\n-   **S** : 文件存盘\n-   **L** : 转换行号\n-   **O** : 转换输出\n-   **Shift-O** : 转换输出滚动\n-   **Esc** : 关闭页面\n-   **Q** : 关闭页面\n-   **H** : 显示快捷键帮助\n-   **I,I** : 中断Notebook内核\n-   **0,0** : 重启Notebook内核\n-   **Shift** : 忽略\n-   **Shift-Space** : 向上滚动\n-   **Space** : 向下滚动\n\n### **编辑模式 ( Enter 键启动)**\n\n-   **Tab** : 代码补全或缩进\n-   **Shift-Tab** : 提示\n-   **Ctrl-\\]** : 缩进\n-   **Ctrl-\\[** : 解除缩进\n-   **Ctrl-A** : 全选\n-   **Ctrl-Z** : 复原\n-   **Ctrl-Shift-Z** : 再做\n-   **Ctrl-Y** : 再做\n-   **Ctrl-Home** : 跳到单元开头\n-   **Ctrl-Up** : 跳到单元开头\n-   **Ctrl-End** : 跳到单元末尾\n-   **Ctrl-Down** : 跳到单元末尾\n-   **Ctrl-Left** : 跳到左边一个字首\n-   **Ctrl-Right** : 跳到右边一个字首\n-   **Ctrl-Backspace** : 删除前面一个字\n-   **Ctrl-Delete** : 删除后面一个字\n-   **Esc** : 进入命令模式\n-   **Ctrl-M** : 进入命令模式\n-   **Shift-Enter** : 运行本单元，选中下一单元\n-   **Ctrl-Enter** : 运行本单元\n-   **Alt-Enter** : 运行本单元，在下面插入一单元\n-   **Ctrl-Shift--** : 分割单元\n-   **Ctrl-Shift-Subtract** : 分割单元\n-   **Ctrl-S** : 文件存盘\n-   **Shift** : 忽略\n-   **Up** : 光标上移或转入上一单元\n-   **Down** :光标下移或转入下一单元","tags":[{"name":"Python","slug":"Python","permalink":"https://xuyuquan0713.github.io/tags/Python/"}]},{"title":"钩子函数","date":"2021-04-24T08:36:42.000Z","path":"2021/04/24/钩子函数/","text":"钩子函数钩子函数也叫回调函数，是通过函数指针来实现的，那我们来看看什么是函数指针。 首先看看以下例子： int *p; int a，b； 我们可以让指针p先后指向a, b，这样，p就先后代表了不同变量的地址 p = &amp;a; p = &amp;b; 同样地，函数的指针可以指向不同的函数，从而完成不同的功能。话说， 函数指针是怎么定义呢？ 函数指针和普通的指针没什么区别，只是函数指针是指向函数的指针。函数指针的定义方式起始和函数声明方式类似， 说白了就是函数声明，唯一不同的是定义的函数指针是可以指向任何具有相同传入参数和相同返回类型的函数，说这么多还不如举个例子来的实际点。 int (*g_pFun) (int x, int y); 这里定义了一个返回值为int类型，有两个int类型传入参数的函数，假如我在写代码的时候，写了一个这样的函数： int Max(int x, int y) &#123; &#125; Max函数是返回int类型，传入两个int类型参数的函数，这个函数类型是不是和我们定义的g_pFun的函数类型一致， 那么g_pFun可以指向Max，g_pFun = Max; 这样我们就可以使用g_pFun 来调用Max函数了， 比如，g_pFun(10, 12)和Max（10， 12）是一样的效果。说到这里，大家已经明白函数指针的用法了吧？ 接下来我们看一个函数指针的实例代码： #include \"stdio.h\" void fun1(void) &#123; printf(\"i am fun1\\r\\n\"); &#125; void fun2(void) &#123; printf(\"i am fun2\\r\\n\"); &#125; int main(int argc, char const *argv[]) &#123; void (* fun)(void); //定义一个函数指针 // 让fun指向fun1 fun = fun1; // 执行fun fun(); // 让fun指向fun2 fun = fun2; // 执行fun fun(); return 0; &#125; 这段代码中，首先写了两个无传入参数，无返回值的函数fun1 和 fun2， 然后定义了一个无返回值无传入参数的函数指针；main函数通过将fun指向fun1和fun2 然后再执行fun，达到调用fun1和fun2的作用。 运行结果： 其实说到这，我们已经会用钩子函数了，只是还没引入专业术语而已，在这里，fun 1和fun 2就是钩子函数，把函数指针fun指向fun 1和fun 2的过程称为“挂钩子”， 这个很形象吧。其实在这有人会问，为什么我不直接调用fun 1和fun 2函数，偏偏要通过定义一个函数指针来实现，这不是变得更麻烦，说到这，我只想说有些实物是适合在不同的场合，不是一定得这样用的， 我先说说一个场景。这是因为，我们在写main函数的时候，可能还不知道它会完成什么功能，这时候留下函数指针作为接口，可以挂上不同的函数完成不同的功能，究竟执行什么功能由钩子函数的编写者完成。 那我们平时怎么用的呢？ 在我们的代码中，常常把挂钩子的过程叫做注册，会提供一个注册函数，让使用者把自己编写的钩子函数挂在已经声明的函数指针上，这个注册函数的参数就是我们的函数指针了，比如，我们可以给刚才的函数指针提供一个注册函数： int RegFun(int(*pFun)(int x, int y)) \\*****注册函数的参数是函数指针***\\ &#123; g_pFun &#x3D; pFun; return 0; &#125; 那么上述代码改为以下代码： #include &quot;stdio.h&quot; void (* fun)(void); &#x2F;&#x2F;定义一个函数指针 void fun1(void) &#123; printf(&quot;i am fun1\\r\\n&quot;); &#125; void fun2(void) &#123; printf(&quot;i am fun2\\r\\n&quot;); &#125; int RegFun(void (*pFun)(void))&#x2F;&#x2F;形参为函数相应类型的函数指针 &#123; fun &#x3D; pFun; &#x2F;&#x2F;将pFun挂钩子 return 0; &#125; int main(int argc, char const *argv[]) &#123; &#x2F;&#x2F; 挂fun1钩子函数 RegFun(fun1); &#x2F;&#x2F; 执行fun fun(); &#x2F;&#x2F; 挂fun2钩子函数 RegFun(fun2); &#x2F;&#x2F; 执行fun fun(); return 0; &#125; 注意：为了便于使用，函数指针往往被声明为全局变量，这也是刚才把函数指针的名字命名为g_pFun的原因。 下面我们来进行一下实战演习，比如，平台部分要执行某一个操作，但是具体的操作还不确定，我们完成这样的代码： #include &quot;stdio.h&quot; int (* g_pFun) (int x, int y); &#x2F;*函数指针*&#x2F; int Plat(void) &#123; int r; int a &#x3D; 10; int b &#x3D; 15; r &#x3D; g_pFun(a, b); printf(&quot;%d\\n&quot;, r); return 0; &#125; &#x2F;&#x2F;另外，平台部分再提供一个注册函数： int RegFun(int (*pFun)(int x, int y)) &#123; g_pFun &#x3D; pFun; return 0; &#125; &#x2F;&#x2F;应用模块完成具体的函数的功能： int Max(int x, int y) &#123; if(x &gt; y) &#123; return x; &#125; else &#123; return y; &#125; &#125; int Min(int x, int y) &#123; if (x &lt; y) return x; else return y; &#125; int main(int argc, char const *argv[]) &#123; &#x2F;* code *&#x2F; RegFun(Min); Plat(); RegFun(Max); Plat(); return 0; &#125; 在嵌入式系统中，底层不知道应用层需要完成什么功能， 往往会提供像这样子的函数回调方式供应用层使用。","raw":"---\ntitle: 钩子函数\nauther: yuquan\nreward: false\ndate: 2021-04-24 16:36:42\ntags: 函数\ncategories: 函数用法\n---\n\n\n\n# 钩子函数\n\n***钩子函数也叫回调函数，是通过函数指针来实现的，那我们来看看什么是函数指针*。**\n\n<!--more-->\n\n首先看看以下例子：\n\n```c\nint *p;\nint a，b；\n```\n\n我们可以让指针p先后指向a, b，这样，p就先后代表了不同变量的地址\n\n```c\np = &a;\np = &b;\n```\n\n同样地，函数的指针可以指向不同的函数，从而完成不同的功能。话说， 函数指针是怎么定义呢？ 函数指针和普通的指针没什么区别，只是函数指针是指向函数的指针。函数指针的定义方式起始和函数声明方式类似， 说白了就是函数声明，唯一不同的是定义的函数指针是可以指向任何具有相同传入参数和相同返回类型的函数，说这么多还不如举个例子来的实际点。\n\n`int (*g_pFun) (int x, int y);` 这里定义了一个返回值为int类型，有两个int类型传入参数的函数，假如我在写代码的时候，写了一个这样的函数：\n\n```c\nint Max(int x, int y)\n{\n}\n```\n\nMax函数是返回int类型，传入两个int类型参数的函数，这个函数类型是不是和我们定义的g\\_pFun的函数类型一致， 那么g\\_pFun可以指向Max，g\\_pFun = Max;  这样我们就可以使用g\\_pFun 来调用Max函数了， 比如，g\\_pFun(10, 12)和Max（10， 12）是一样的效果。说到这里，大家已经明白函数指针的用法了吧？\n\n接下来我们看一个函数指针的实例代码：\n\n```c\n#include \"stdio.h\"\n \nvoid fun1(void)\n{\n    printf(\"i am fun1\\r\\n\");\n}\n \nvoid fun2(void)\n{\n    printf(\"i am fun2\\r\\n\");\n}\n \nint main(int argc, char const *argv[])\n{\n    void (* fun)(void); //定义一个函数指针\n \n    // 让fun指向fun1\n    fun = fun1;\n    // 执行fun\n    fun();\n \n    // 让fun指向fun2\n    fun = fun2;\n    // 执行fun\n    fun();\n \n    return 0;\n}\n```\n\n这段代码中，首先写了两个无传入参数，无返回值的函数fun1 和 fun2， 然后定义了一个无返回值无传入参数的函数指针；main函数通过将fun指向fun1和fun2 然后再执行fun，达到调用fun1和fun2的作用。\n\n运行结果：\n\n![](https://gitee.com/xu-yuquan/picture-markdown/raw/master/20210424.png)\n\n其实说到这，我们已经会用钩子函数了，只是还没引入专业术语而已，在这里，fun 1和fun 2就是钩子函数，把函数指针fun指向fun 1和fun 2的过程称为“挂钩子”， 这个很形象吧。其实在这有人会问，为什么我不直接调用fun 1和fun 2函数，偏偏要通过定义一个函数指针来实现，这不是变得更麻烦，说到这，我只想说有些实物是适合在不同的场合，不是一定得这样用的， 我先说说一个场景。这是因为，我们在写main函数的时候，可能还不知道它会完成什么功能，这时候留下函数指针作为接口，可以挂上不同的函数完成不同的功能，究竟执行什么功能由钩子函数的编写者完成。\n\n那我们平时怎么用的呢？\n\n在我们的代码中，常常把挂钩子的过程叫做注册，会提供一个注册函数，让使用者把自己编写的钩子函数挂在已经声明的函数指针上，这个注册函数的参数就是我们的函数指针了，比如，我们可以给刚才的函数指针提供一个注册函数：\n\n```\nint RegFun(int(*pFun)(int x, int y))    \\*****注册函数的参数是函数指针***\\\n\n{\n    g_pFun = pFun;\n\n    return 0;\n}\n```\n\n那么上述代码改为以下代码：\n\n```\n#include \"stdio.h\"\n \nvoid (* fun)(void); //定义一个函数指针\n \nvoid fun1(void)\n{\n    printf(\"i am fun1\\r\\n\");\n}\n \nvoid fun2(void)\n{\n    printf(\"i am fun2\\r\\n\");\n}\n \nint RegFun(void (*pFun)(void))//形参为函数相应类型的函数指针\n{\n    fun = pFun;  //将pFun挂钩子\n    return 0;\n}\n \nint main(int argc, char const *argv[])\n{\n \n    // 挂fun1钩子函数\n    RegFun(fun1);\n     // 执行fun\n    fun();\n \n    // 挂fun2钩子函数\n    RegFun(fun2);\n    // 执行fun\n    fun();\n \n    return 0;\n}\n```\n\n注意：为了便于使用，函数指针往往被声明为全局变量，这也是刚才把函数指针的名字命名为g\\_pFun的原因。\n\n下面我们来进行一下实战演习，比如，平台部分要执行某一个操作，但是具体的操作还不确定，我们完成这样的代码：\n\n```\n#include \"stdio.h\"\n \nint (* g_pFun) (int x, int y);  /*函数指针*/\n \nint Plat(void)\n{\n    int r;\n    int a = 10;\n    int b = 15;\n \n    r = g_pFun(a, b);\n \n    printf(\"%d\\n\", r);\n \n    return 0;\n}\n \n//另外，平台部分再提供一个注册函数：\nint RegFun(int (*pFun)(int x, int y))\n{\n    g_pFun = pFun;\n \n    return 0;\n}\n \n//应用模块完成具体的函数的功能：\nint Max(int x, int y)\n{\n    if(x > y)\n    {\n        return x;\n    }\n    else\n    {\n        return y;\n    }\n}\n \nint Min(int x, int y)\n{\n    if (x < y)\n        return x;\n    else\n        return y;\n}\n \nint main(int argc, char const *argv[])\n{\n    /* code */\n \n    RegFun(Min);\n    Plat();\n \n    RegFun(Max);\n    Plat();\n \n    return 0;\n}\n```\n\n在嵌入式系统中，底层不知道应用层需要完成什么功能， 往往会提供像这样子的函数回调方式供应用层使用。","tags":[{"name":"函数","slug":"函数","permalink":"https://xuyuquan0713.github.io/tags/%E5%87%BD%E6%95%B0/"}]},{"title":"树莓派内网穿透","date":"2021-04-10T14:16:49.000Z","path":"2021/04/10/树莓派内网穿透/","text":"树莓派内网穿透 这是自己最近遇到的一个实际问题。因为在做机器学习的内容，需要训练模型，恰好前几天实验室的老师答应借我服务器一用。可是服务器我又不能搬回寝室。因为我们学校比较特殊，宿舍区域接入了公网IP，而教学区域却没有。想着有公网ip的话，会方便许多。突然想到我不是还有树莓派么，为什么不让树莓派接入公网ip后再内网穿透呢！这是个好主意！ 虽然网上也有关于介绍树莓派使用frp内网穿透的文章。不过这里的场景有所不同。网上的的案例大都是树莓派处于内网中，作为frp客户端，利用公网上的一台vps将树莓派的服务映射到公网上实现穿透。 什么是内网穿透？内网穿透，即NAT穿透，网络连接时术语，计算机是局域网内时，外网与内网的计算机节点需要连接通信，有时就会出现不支持内网穿透。 为什么需要内网穿透功能？因为从公网中访问自己的私有设备向来是一件困难的事情。自己的服务器、NAS等等设备，它们可能处于路由器后，或者运营商因为IP地址短缺不给你分配公网IP地址。如果我们想直接访问到这些设备（远程桌面，远程文件，SSH等等），一般来说要通过一些转发或者P2P组网软件的帮助。 比如我有一台计算机位于一个很复杂的局域网中，我想要实现远程桌面和文件访问，目前来看其所处的网络环境很难通过简单的端口映射将其暴露在公网之中，有这么几种方法： 远程桌面使用TeamViewer。可用，但需要访问端也拥有TeamViewer软件，不是很方便，希望能使用Windows自带的远程桌面。且TeamViewer不易实现远程文件访问。 使用蒲公英VPN软件进行组网，可用，但免费版本网络速度极慢，体验不佳，几乎无法正常使用。 使用花生壳软件进行DDNS解析，可用，但同第二点所述，免费版本有带宽限制，无法实际使用。 搭建frp服务器进行内网穿透，可用且推荐，可以达到不错的速度，且理论上可以开放任何想要的端口，可以实现的功能远不止远程桌面或者文件共享。 frp是什么？简单地说，frp就是一个反向代理软件，它体积轻量但功能很强大，可以使处于内网或防火墙后的设备对外界提供服务，它支持HTTP、TCP、UDP等众多协议。 因为我寝室的网络已经接入联通公网ip了，所以我是将树莓派作为frp服务器，向校园内网里的其他机器提供内网穿透。虽然我也有很多云服务器，但我最终还是选择了树莓派。 最大的原因还是考虑到延时问题。联通提供公网ip和学校的网络同处于一个局域网网内，这样树莓派和需要内网穿透的机器间的延迟就可以忽略不计，那么也就只有远程连接一方和树莓派所处网络间的延迟了。 因为frp是github上的一个开源项目，这里查看官方文档，非常详细。 frp中文文档链接frp服务端搭建因为我使用树莓派作为服务端，所以先下载树莓派对应的版本，截止目前frp最新版本是v0.26.0 如果用的vps，ssh连接到VPS之后运行如下命令查看处理器架构，根据架构下载不同版本的frparch查看结果，如果是“X86_64“即可选择”amd64”， https://github.com/fatedier/frp/releases/ 现在ssh远程连接上我们的树莓派，我是直接su root后以root身份执行的命令，如果你没有，请每一条命令前面带上 sudo 。 wget https://github.com/fatedier/frp/releases/download/v0.26.0/frp\\_0.26.0\\_linux\\_arm.tar.gz tar xvf frp_0.26.0_linux_arm.tar.gz cd frp_0.26.0_linux_arm 这里我们只需要关注如下几个文件 frps frps_full.ini frps.ini 该目录下的文件（s结尾代表server）分别是服务端程序和服务端配置文件，（c结尾代表client）分别是客户端程序和客户端配置文件。 vim frps.ini #编辑服务端配置文件，建议自行修改 [common] bind_port = 7000 dashboard_port = 7500 token = 12345678 dashboard_user = admin dashboard_pwd = admin “bind_port”表示用于客户端和服务端连接的端口，这个端口号我们之后在配置客户端的时候要用到。 “dashboard_port”是服务端仪表板的端口，若使用7500端口，在配置完成服务启动后可以通过浏览器访问 x.x.x.x:7500 （其中x.x.x.x为VPS的IP）查看frp服务运行信息。 “token”是用于客户端和服务端连接的口令，请自行设置并记录，稍后会用到。 “dashboard_user”和“dashboard_pwd”表示打开仪表板页面登录的用户名和密码，自行设置即可。 这样就运行时就执行 ======./frps -c frps.ini== 如果看到屏幕输出这样一段内容，即表示运行正常，如果出现错误提示，请检查上面的步骤。 但是如果想偷懒的话，端口均可使用默认值，token、user和password项请自行设置。直接在frps_full.ini这个它给好的配置文件中修改后运行即可 ./frps -c frps_full.ini 此时访问 你的ip:7500 并使用自己设置的用户名密码登录，即可看到仪表板界面。 让frps在后台运行至此，我们的服务端仅运行在前台，如果Ctrl+C停止或者关闭SSH窗口后，frps均会停止运行，因而我们使用 screen命令将其运行在后台。因为我用的树莓派所以 apt install screen screnn -S frps #新建一个screen名为frps 此时我们就进入了screen里面了。再次执行./frps -c frps.ini 现在直接关闭ssh窗口，frps依旧在运行。frp服务端便搭建完成了。 frp客户端配置frp的客户端就是我们想要真正进行访问的那台设备，大多数情况下应该会是一台Windows主机，因而本文使用Windows主机做例子；Linux配置方法类似。 同样地，根据客户端设备的情况选择相应的frp程序进行下载 用文本编辑器打开frpc.ini，与服务端类似，内容如下。 [common] server_addr = x.x.x.x server_port = 7000 token = 12345678 [rdp] type = tcp local_ip = 127.0.0.1 local_port = 3389 remote_port = 7001 因为我这里以远程桌面来演示，所以就没有添加其他的协议。具体参考frps_full.ini中的配置。 在当前目录下打开cmd窗口，我把背景换成了白色。 执行 frpc -c frpc.ini 不要关闭命令行窗口，此时可以在局域网外使用相应程序访问 x.x.x.x:xxxx （IP为VPS的IP，端口为自定义的remote_port）即可访问到相应服务。 此时我们在另外一台机器上进行远程桌面连接进行测试。 这是我在寝室里演示的，最右边那台主机用树莓派的公网ip加端口成功连接上中间那台内网主机，实现了内网穿透。 大功告成！！！ ———————(本文转载)——————————-","raw":"---\ntitle: 树莓派内网穿透\nauther: yuquan\nreward: false\ndate: 2021-04-10 22:16:49\ntags: 树莓派\ncategories: 树莓派\n\n---\n\n## 树莓派内网穿透\n\n<!--more-->\n\n-------------------------------------------------------\n\n这是自己最近遇到的一个实际问题。因为在做机器学习的内容，需要训练模型，恰好前几天实验室的老师答应借我服务器一用。可是服务器我又不能搬回寝室。因为我们学校比较特殊，宿舍区域接入了公网IP，而教学区域却没有。想着有公网ip的话，会方便许多。突然想到我不是还有树莓派么，为什么不让树莓派接入公网ip后再内网穿透呢！这是个好主意！\n--------------------------------\n\n\n\n\n\n![](https://zgao.top//wp-content/uploads/2019/04/TIM%E5%9B%BE%E7%89%8720190420132638-300x155.jpg)\n\n\n\n虽然网上也有关于介绍树莓派使用frp内网穿透的文章。不过这里的场景有所不同。网上的的案例大都是树莓派处于内网中，作为frp客户端，利用公网上的一台vps将树莓派的服务映射到公网上实现穿透。\n\n\n#### 什么是内网穿透？\n\n内网穿透，即NAT穿透，网络连接时术语，计算机是局域网内时，外网与内网的计算机节点需要连接通信，有时就会出现不支持内网穿透。\n\n#### 为什么需要内网穿透功能？\n\n因为**从公网中访问自己的私有设备向来是一件困难的事情。** \n自己的服务器、NAS等等设备，它们可能处于路由器后，或者运营商因为IP地址短缺不给你分配公网IP地址。如果我们想直接访问到这些设备（远程桌面，远程文件，SSH等等），一般来说要通过一些转发或者P2P组网软件的帮助。\n\n比如我有一台计算机位于一个很复杂的局域网中，我想要实现远程桌面和文件访问，目前来看其所处的网络环境很难通过简单的端口映射将其暴露在公网之中，有这么几种方法：\n\n1.  远程桌面使用TeamViewer。可用，但需要访问端也拥有TeamViewer软件，不是很方便，希望能使用Windows自带的远程桌面。且TeamViewer不易实现远程文件访问。\n2.  使用蒲公英VPN软件进行组网，可用，但免费版本网络速度极慢，体验不佳，几乎无法正常使用。\n3.  使用花生壳软件进行DDNS解析，可用，但同第二点所述，免费版本有带宽限制，无法实际使用。\n4.  ****搭建frp服务器进行内网穿透，可用且推荐，可以达到不错的速度，且理论上可以开放任何想要的端口，可以实现的功能远不止远程桌面或者文件共享。****\n\n___\n\n### frp是什么？\n\n简单地说，[frp](https://github.com/fatedier/frp/blob/master/README_zh.md \"frp\")就是一个反向代理软件，它体积轻量但功能很强大，可以**使处于内网或防火墙后的设备对外界提供服务**，它支持HTTP、TCP、UDP等众多协议。\n\n因为我寝室的网络已经接入联通公网ip了，所以我是将树莓派作为frp服务器，向校园内网里的其他机器提供内网穿透。虽然我也有很多云服务器，但我最终还是选择了树莓派。\n\n最大的原因还是考虑到延时问题。联通提供公网ip和学校的网络同处于一个局域网网内，这样树莓派和需要内网穿透的机器间的延迟就可以忽略不计，那么也就只有远程连接一方和树莓派所处网络间的延迟了。\n\n因为frp是github上的一个开源项目，这里查看官方文档，非常详细。\n\n### [frp中文文档链接](https://github.com/fatedier/frp/blob/master/README_zh.md)\n\n\n\n### frp服务端搭建\n\n因为我使用树莓派作为服务端，所以先下载树莓派对应的版本，截止目前frp最新版本是[v0.26.0](https://github.com/fatedier/frp/releases/tag/v0.26.0)\n\n如果用的vps，ssh连接到VPS之后运行如下命令查看处理器架构，根据架构下载不同版本的frp  \n`arch` \n查看结果，如果是“X86\\_64“即可选择”amd64”，\n\n[https://github.com/fatedier/frp/releases/](https://github.com/fatedier/frp/releases/)\n\n![](https://zgao.top//wp-content/uploads/2019/04/TIM%E6%88%AA%E5%9B%BE20190420141048-300x103.png)\n\n现在ssh远程连接上我们的树莓派，我是直接su root后以root身份执行的命令，如果你没有，请每一条命令前面带上   sudo 。\n\nwget https://github.com/fatedier/frp/releases/download/v0.26.0/frp\\_0.26.0\\_linux\\_arm.tar.gz\n\ntar xvf frp\\_0.26.0\\_linux\\_arm.tar.gz\n\ncd frp\\_0.26.0\\_linux\\_arm\n\n![](https://zgao.top//wp-content/uploads/2019/04/TIM%E6%88%AA%E5%9B%BE20190420141945-300x41.png)\n\n这里我们只需要关注如下几个文件\n\n-   frps\n-   frps\\_full.ini\n-   frps.ini\n\n该目录下的文件（s结尾代表server）分别是服务端程序和服务端配置文件，（c结尾代表client）分别是客户端程序和客户端配置文件。\n\nvim   frps.ini       #编辑服务端配置文件，建议自行修改\n\n> \\[common\\]\n>\n> bind\\_port = 7000\n>\n> dashboard\\_port = 7500\n>\n> token = 12345678\n>\n> dashboard\\_user = admin\n>\n> dashboard\\_pwd = admin\n\n___\n\n-   “bind\\_port”表示用于客户端和服务端连接的端口，这个端口号我们之后在配置客户端的时候要用到。\n-   “dashboard\\_port”是服务端仪表板的端口，若使用7500端口，在配置完成服务启动后可以通过浏览器访问 x.x.x.x:7500 （其中x.x.x.x为VPS的IP）查看frp服务运行信息。\n-   “token”是用于客户端和服务端连接的口令，请自行设置并记录，稍后会用到。\n-   “dashboard\\_user”和“dashboard\\_pwd”表示打开仪表板页面登录的用户名和密码，自行设置即可。\n\n___\n\n这样就运行时就执行\n\n======./frps -c frps.ini==\n\n![](https://zgao.top//wp-content/uploads/2019/04/TIM%E5%9B%BE%E7%89%8720190420144358-300x49.png)\n\n如果看到屏幕输出这样一段内容，即表示运行正常，如果出现错误提示，请检查上面的步骤。\n\n但是如果想偷懒的话，端口均可使用默认值，token、user和password项请自行设置。直接在frps\\_full.ini这个它给好的配置文件中修改后运行即可\n\n./frps -c frps\\_full.ini\n\n此时访问  你的ip:7500 并使用自己设置的用户名密码登录，即可看到仪表板界面。\n\n![](https://zgao.top//wp-content/uploads/2019/04/TIM%E6%88%AA%E5%9B%BE20190420144648-300x128.png)\n\n#### 让frps在后台运行\n\n至此，我们的服务端仅运行在前台，如果Ctrl+C停止或者关闭SSH窗口后，frps均会停止运行，因而我们使用 screen命令将其运行在后台。因为我用的树莓派所以\n\napt install screen\n\nscrenn -S frps     #新建一个screen名为frps\n\n此时我们就进入了screen里面了。再次执行./frps -c frps.ini\n\n现在直接关闭ssh窗口，frps依旧在运行。frp服务端便搭建完成了。\n\n### frp客户端配置\n\nfrp的客户端就是我们想要真正进行访问的那台设备，大多数情况下应该会是一台Windows主机，因而本文使用Windows主机做例子；Linux配置方法类似。\n\n同样地，根据客户端设备的情况选择相应的frp程序进行[下载](https://github.com/fatedier/frp/releases \"下载\")\n\n![](https://zgao.top//wp-content/uploads/2019/04/TIM%E6%88%AA%E5%9B%BE20190420150206-300x73.png)\n\n用文本编辑器打开frpc.ini，与服务端类似，内容如下。\n\n> \\[common\\]\n>\n> server\\_addr = x.x.x.x\n>\n> server\\_port = 7000\n>\n> token = 12345678\n>\n> \\[rdp\\]\n>\n> type = tcp\n>\n> local\\_ip = 127.0.0.1\n>\n> local\\_port = 3389\n>\n> remote\\_port = 7001\n\n因为我这里以远程桌面来演示，所以就没有添加其他的协议。具体参考frps\\_full.ini中的配置。\n\n在当前目录下打开cmd窗口，我把背景换成了白色。\n\n执行  frpc -c frpc.ini\n\n![](https://zgao.top//wp-content/uploads/2019/04/TIM%E6%88%AA%E5%9B%BE20190420150921-300x121.png)\n\n不要关闭命令行窗口，此时可以在局域网外使用相应程序访问 x.x.x.x:xxxx （IP为VPS的IP，端口为自定义的remote\\_port）即可访问到相应服务。\n\n此时我们在另外一台机器上进行远程桌面连接进行测试。\n\n![](https://zgao.top//wp-content/uploads/2019/04/TIM%E6%88%AA%E5%9B%BE20190420152739-300x124.png)\n\n这是我在寝室里演示的，最右边那台主机用树莓派的公网ip加端口成功连接上中间那台内网主机，实现了内网穿透。\n\n大功告成！！！\n\n---------------------(本文转载)-------------------------------","tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://xuyuquan0713.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"常用的Linux命令","date":"2021-04-06T16:00:00.000Z","path":"2021/04/07/linux常用命令/","text":"常用的 linux 命令 ls就是 list 的缩写，通过 ls 命令不仅可以查看 linux 文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。 常用参数搭配： ls -a #列出目录所有文件，包含以.开始的隐藏文件 ls -A #列出除.及..的其它文件 ls -r #反序排列 ls -t #以文件修改时间排序 ls -S #以文件大小排序 ls -h #以易读大小显示 ls -l #除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来 实例： 按易读方式按时间反序排序，并显示文件详细信息 ls -lhrt 按大小反序显示文件详细信息 ls -lrS 列出当前目录中所有以”t”开头的目录的详细内容 ls -l t* 列出文件绝对路径（不包含隐藏文件） ls | sed &quot;s:^:&#96;pwd&#96;&#x2F;:&quot; 列出文件绝对路径（包含隐藏文件） find $pwd -maxdepth 1 | xargs ls -ld cdcd(changeDirectory) 命令语法： cd [目录名] 说明：切换当前目录至 dirName。 实例： 进入要目录 cd &#x2F; 进入 “home” 目录 cd ~ 进入上一次工作路径 cd - 把上个命令的参数作为 cd 参数使用。 cd !$ pwdpwd 命令用于查看当前工作目录路径。 实例： 查看当前路径 pwd 查看软链接的实际路径 pwd -P mkdirmkdir 命令用于创建文件夹。 可用选项： -m: 对新建目录设置存取权限，也可以用 chmod 命令设置; -p: 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后，系统将自动建立好那些尚不在的目录，即一次可以建立多个目录。 实例： 当前工作目录下创建名为 t 的文件夹 mkdir t 在 tmp 目录下创建路径为 test/t1/t 的目录，若不存在，则创建： mkdir -p &#x2F;tmp&#x2F;test&#x2F;t1&#x2F;t rm删除一个目录中的一个或多个文件或目录，如果没有使用 -r 选项，则 rm 不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。 rm [选项] 文件… 实例： 删除任何 .log 文件，删除前逐一询问确认： rm -i *.log 删除 test 子目录及子目录中所有档案删除，并且不用一一确认： rm -rf test 删除以 -f 开头的文件 rm -- -f* rmdir从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。 注意：不能删除非空目录 实例： 当 parent 子目录被删除后使它也成为空目录的话，则顺便一并删除： rmdir -p parent&#x2F;child&#x2F;child11 mv移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。 当第二个参数为目录时，第一个参数可以是多个以空格分隔的文件或目录，然后移动第一个参数指定的多个文件到第二个参数指定的目录中。 实例： 将文件 test.log 重命名为 test1.txt mv test.log test1.txt 将文件 log1.txt,log2.txt,log3.txt 移动到根的 test3 目录中 mv llog1.txt log2.txt log3.txt &#x2F;test3 将文件 file1 改名为 file2，如果 file2 已经存在，则询问是否覆盖 mv -i log1.txt log2.txt 移动当前文件夹下的所有文件到上一级目录 mv * ..&#x2F; cp将源文件复制至目标文件，或将多个源文件复制至目标目录。 注意：命令行复制，如果目标文件已经存在会提示是否覆盖，而在 shell 脚本中，如果不加 -i 参数，则不会提示，而是直接覆盖！ -i #提示 -r #复制目录及目录内所有项目 -a #复制的文件与原文件时间一样 实例： 复制 a.txt 到 test 目录下，保持原文件时间，如果原文件存在提示是否覆盖。 cp -ai a.txt test 为 a.txt 建议一个链接（快捷方式） cp -s a.txt link_a.txt catcat 主要有三大功能： 一次显示整个文件: cat filename 从键盘创建一个文件: cat &gt; filename 只能创建新文件，不能编辑已有文件。 将几个文件合并为一个文件: cat file1 file2 &gt; file -b 对非空输出行号 -n 输出所有行号 实例： 把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里 cat -n log2012.log log2013.log 把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里 cat -b log2012.log log2013.log log.log 使用 here doc 生成新文件 cat &gt;log.txt &lt;&lt;EOF &gt;Hello &gt;World &gt;PWD&#x3D;$(pwd) &gt;EOF ls -l log.txt cat log.txt Hello World PWD&#x3D;&#x2F;opt&#x2F;soft&#x2F;test 反向列示 tac log.txt PWD&#x3D;&#x2F;opt&#x2F;soft&#x2F;test World Hello more功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。 命令参数： +n #从笫 n 行开始显示 -n #定义屏幕大小为n行 +&#x2F;pattern #在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c #从顶部清屏，然后显示 -d #提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能 -l #忽略Ctrl+l（换页）字符 -p #通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似 -s #把连续的多个空行显示为一行 -u #把文件内容中的下画线去掉 常用操作命令： Enter #向下 n 行，需要定义。默认为 1 行 Ctrl+F #向下滚动一屏 空格键 #向下滚动一屏 Ctrl+B #返回上一屏 &#x3D; #输出当前行的行号 :f #输出文件名和当前行的行号 V #调用vi编辑器 !命令 #调用Shell，并执行命令 q #退出more 实例： 显示文件中从第 3 行起的内容 more +3 text.txt 在所列出文件目录详细信息，借助管道使每次显示 5 行 ls -l | more -5 按空格显示下 5 行。 lessless 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。 常用命令参数： -i 忽略搜索时的大小写 -N 显示每行的行号 -o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来 -s 显示连续空行为一行 &#x2F;字符串：向下搜索“字符串”的功能 ?字符串：向上搜索“字符串”的功能 n：重复前一个搜索（与 &#x2F; 或 ? 有关） N：反向重复前一个搜索（与 &#x2F; 或 ? 有关） -x &lt;数字&gt; 将“tab”键显示为规定的数字空格 b 向后翻一页 d 向后翻半页 h 显示帮助界面 Q 退出less 命令 u 向前滚动半页 y 向前滚动一行 空格键 滚动一行 回车键 滚动一页 [pagedown]： 向下翻动一页 [pageup]： 向上翻动一页 实例： ps 查看进程信息并通过 less 分页显示 ps -aux | less -N 查看多个文件 less 1.log 2.log 可以使用 n 查看下一个，使用 p 查看前一个。 headhead 用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。 常用参数： -n&lt;行数&gt; 显示的行数（行数为复数表示从最后向前数） 实例： 显示 1.log 文件中前 20 行 head 1.log -n 20 显示 1.log 文件前 20 字节 head -c 20 log2014.log 显示 t.log 最后 10 行 head -n -10 t.log tail用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。 常用参数： -f 循环读取（常用于查看递增的日志文件） -n&lt;行数&gt; 显示行数（从后向前） 循环读取逐渐增加的文件内容 ping 127.0.0.1 &gt; ping.log &amp; 后台运行：可使用 jobs -l 查看，也可使用 fg 将其移到前台运行。 tail -f ping.log （查看日志） which在 linux 要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索： which 查看可执行文件的位置。 whereis 查看文件的位置。 locate 配合数据库查看文件位置。 find 实际搜寻硬盘查询文件名称。 which 是在 PATH 就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 常用参数： -n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。 实例： 查看 ls 命令是否存在，执行哪个 which ls 查看 which which which 查看 cd which cd（显示不存在，因为 cd 是内建命令，而 which 查找显示是 PATH 中的命令） 查看当前 PATH 配置： echo $PATH 或使用 env 查看所有环境变量及对应值 whereiswhereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man 说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。whereis 及 locate 都是基于系统内建的数据库进行搜索，因此效率很高，而 find 则是遍历硬盘查找文件。 常用参数： -b 定位可执行文件。 -m 定位帮助文件。 -s 定位源代码文件。 -u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。 实例： 查找 locate 程序相关文件 whereis locate 查找 locate 的源码文件 whereis -s locate 查找 lcoate 的帮助文件 whereis -m locate locatelocate 通过搜寻系统内建文档数据库达到快速找到档案，数据库由 updatedb 程序来更新，updatedb 是由 cron daemon 周期性调用的。默认情况下 locate 命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是 locate 所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb 每天会跑一次，可以由修改 crontab 来更新设定值 (etc/crontab)。 locate 与 find 命令相似，可以使用如 *、? 等进行正则匹配查找 常用参数： -l num（要显示的行数） -f 将特定的档案系统排除在外，如将proc排除在外 -r 使用正则运算式做为寻找条件 实例： 查找和 pwd 相关的所有文件(文件名中包含 pwd） locate pwd 搜索 etc 目录下所有以 sh 开头的文件 locate &#x2F;etc&#x2F;sh 查找 /var 目录下，以 reason 结尾的文件 locate -r &#39;^&#x2F;var.*reason$&#39;（其中.表示一个字符，*表示任务多个；.*表示任意多个字符） find用于在文件树中查找文件，并作出相应的处理。 命令格式： find pathname -options [-print -exec -ok ...] 命令参数： pathname: find命令所查找的目录路径。例如用.来表示当前目录，用&#x2F;来表示系统根目录。 -print： find命令将匹配的文件输出到标准输出。 -exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为&#39;command&#39; &#123; &#125; \\;，注意&#123; &#125;和\\；之间的空格。 -ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。 命令选项： -name 按照文件名查找文件 -perm 按文件权限查找文件 -user 按文件属主查找文件 -group 按照文件所属的组来查找文件。 -type 查找某一类型的文件，诸如： b - 块设备文件 d - 目录 c - 字符设备文件 l - 符号链接文件 p - 管道文件 f - 普通文件 -size n :[c] 查找文件长度为n块文件，带有c时表文件字节大小 -amin n 查找系统中最后N分钟访问的文件 -atime n 查找系统中最后n*24小时访问的文件 -cmin n 查找系统中最后N分钟被改变文件状态的文件 -ctime n 查找系统中最后n*24小时被改变文件状态的文件 -mmin n 查找系统中最后N分钟被改变文件数据的文件 -mtime n 查找系统中最后n*24小时被改变文件数据的文件 (用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。 ) -maxdepth n 最大查找目录深度 -prune 选项来指出需要忽略的目录。在使用-prune选项时要当心，因为如果你同时使用了-depth选项，那么-prune选项就会被find命令忽略 -newer 如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项 实例： 查找 48 小时内修改过的文件 find -atime -2 在当前目录查找 以 .log 结尾的文件。 . 代表当前目录 find .&#x2F; -name &#39;*.log&#39; 查找 /opt 目录下 权限为 777 的文件 find &#x2F;opt -perm 777 查找大于 1K 的文件 find -size +1000c 查找等于 1000 字符的文件 find -size 1000c -exec 参数后面跟的是 command 命令，它的终止是以 ; 为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。&#123;&#125; 花括号代表前面find查找出来的文件名。 实例： 在当前目录中查找更改时间在 10 日以前的文件并删除它们(无提醒） find . -type f -mtime +10 -exec rm -f &#123;&#125; \\; 当前目录中查找所有文件名以.log 结尾、更改时间在 5 日以上的文件，并删除它们，只不过在删除之前先给出提示。 按 y 键删除文件，按 n 键不删除 find . -name &#39;*.log&#39; mtime +5 -ok -exec rm &#123;&#125; \\; 当前目录下查找文件名以 passwd 开头，内容包含 “pkg” 字符的文件 find . -f -name &#39;passwd*&#39; -exec grep &quot;pkg&quot; &#123;&#125; \\; 用 exec 选项执行 cp 命令 find . -name &#39;*.log&#39; -exec cp &#123;&#125; test3 \\; -xargs find 命令把匹配到的文件传递给 xargs 命令，而 xargs 命令每次只获取一部分文件而不是全部，不像 -exec 选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。 实例： 查找当前目录下每个普通文件，然后使用 xargs 来判断文件类型 find . -type f -print | xargs file 查找当前目录下所有以 js 结尾的并且其中包含 ‘editor’ 字符的普通文件 find . -type f -name &quot;*.js&quot; -exec grep -lF &#39;ueditor&#39; &#123;&#125; \\; find -type f -name &#39;*.js&#39; | xargs grep -lF &#39;editor&#39; 利用 xargs 执行 mv 命令 find . -name &quot;*.log&quot; | xargs -i mv &#123;&#125; test4 用 grep 命令在当前目录下的所有普通文件中搜索 hostnames 这个词，并标出所在行： find . -name \\*(转义） -type f -print | xargs grep -n &#39;hostnames&#39; 查找当前目录中以一个小写字母开头，最后是 4 到 9 加上 .log 结束的文件： find . -name &#39;[a-z]*[4-9].log&#39; -print 在 test 目录查找不在 test4 子目录查找 find test -path &#39;test&#x2F;test4&#39; -prune -o -print 实例 1：查找更改时间比文件 log2012.log 新但比文件 log2017.log 旧的文件 find -newer log2012.log ! -newer log2017.log 使用 depth 选项： depth 选项可以使 find 命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件。 实例：find 命令从文件系统的根目录开始，查找一个名为 CON.FILE 的文件。 它将首先匹配所有的文件然后再进入子目录中查找 find &#x2F; -name &quot;CON.FILE&quot; -depth -print chmod用于改变 linux 系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。 每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。可使用 ls -l test.txt 查找。 以文件 log2012.log 为例： -rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log 第一列共有 10 个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是 d，表示是一个目录。从第二个字符开始到第十个 9 个字符，3 个字符一组，分别表示了 3 组用户对文件或者目录的权限。权限字符用横线代表空许可，r 代表只读，w 代表写，x 代表可执行。 常用参数： -c 当发生改变时，报告处理信息 -R 处理指定目录以及其子目录下所有文件 权限范围： u ：目录或者文件的当前的用户 g ：目录或者文件的当前的群组 o ：除了目录或者文件的当前用户或群组之外的用户或者群组 a ：所有的用户及群组 权限代号： r ：读权限，用数字4表示 w ：写权限，用数字2表示 x ：执行权限，用数字1表示 - ：删除权限，用数字0表示 s ：特殊权限 实例： 增加文件 t.log 所有用户可执行权限 chmod a+x t.log 撤销原来所有的权限，然后使拥有者具有可读权限,并输出处理信息 chmod u&#x3D;r t.log -c 给 file 的属主分配读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限 chmod 751 t.log -c（或者：chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x t.log -c) 将 test 目录及其子目录所有文件添加可读权限 chmod u+r,g+r,o+r -R text&#x2F; -c19、tar 命令 用来压缩和解压文件。tar 本身不具有压缩功能，只具有打包功能，有关压缩及解压是调用其它的功能来完成。 弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件 常用参数： -c 建立新的压缩文件 -f 指定压缩文件 -r 添加文件到已经压缩文件包中 -u 添加改了和现有的文件到压缩包中 -x 从压缩包中抽取文件 -t 显示压缩文件中的内容 -z 支持gzip压缩 -j 支持bzip2压缩 -Z 支持compress解压文件 -v 显示操作过程 有关 gzip 及 bzip2 压缩: gzip 实例：压缩 gzip fileName .tar.gz 和.tgz 解压：gunzip filename.gz 或 gzip -d filename.gz 对应：tar zcvf filename.tar.gz tar zxvf filename.tar.gz bz2实例：压缩 bzip2 -z filename .tar.bz2 解压：bunzip filename.bz2或bzip -d filename.bz2 对应：tar jcvf filename.tar.gz 解压：tar jxvf filename.tar.bz2 实例： 将文件全部打包成 tar 包 tar -cvf log.tar 1.log,2.log 或tar -cvf log.* 将 /etc 下的所有文件及目录打包到指定目录，并使用 gz 压缩 tar -zcvf &#x2F;tmp&#x2F;etc.tar.gz &#x2F;etc 查看刚打包的文件内容（一定加 z，因为是使用 gzip 压缩的） tar -ztvf &#x2F;tmp&#x2F;etc.tar.gz 要压缩打包 /home, /etc ，但不要 /home/dmtsai tar --exclude &#x2F;home&#x2F;dmtsai -zcvf myfile.tar.gz &#x2F;home&#x2F;* &#x2F;etc chownchown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID；组可以是组名或者组 ID；文件是以空格分开的要改变权限的文件列表，支持通配符。 -c 显示更改的部分的信息 -R 处理指定目录及子目录 实例： 改变拥有者和群组 并显示改变信息 chown -c mail:mail log2012.log 改变文件群组 chown -c :mail t.log 改变文件夹及子文件目录属主及属组为 mail chown -cR mail: test&#x2F; df显示磁盘空间使用情况。获取硬盘被占用了多少空间，目前还剩下多少空间等信息，如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以 512 字节为单位进行显示： -a 全部文件系统列表 -h 以方便阅读的方式显示信息 -i 显示inode信息 -k 区块为1024字节 -l 只显示本地磁盘 -T 列出文件系统类型 实例： 显示磁盘使用情况 df -l 以易读方式列出所有文件系统及其类型 df -haT dudu 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看： 命令格式： du [选项] [文件] 常用参数： -a 显示目录中所有文件大小 -k 以KB为单位显示文件大小 -m 以MB为单位显示文件大小 -g 以GB为单位显示文件大小 -h 以易读方式显示文件大小 -s 仅显示总计 -c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和 实例： 以易读方式显示文件夹内及子文件夹大小 du -h scf&#x2F; 以易读方式显示文件夹内所有文件大小 du -ah scf&#x2F; 显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和 du -hc test&#x2F; scf&#x2F; 输出当前目录下各个子目录所使用的空间 du -hc --max-depth&#x3D;1 scf&#x2F; ln功能是为文件在另外一个位置建立一个同步的链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过 ln 创建的链接（link）减少磁盘占用量。 链接分类：软件链接及硬链接 软链接： 软链接，以路径的形式存在。类似于 Windows 操作系统中的快捷方式 软链接可以 跨文件系统 ，硬链接不可以 软链接可以对一个不存在的文件名进行链接 软链接可以对目录进行链接 硬链接: 硬链接，以文件副本的形式存在。但不占用实际空间。 不允许给目录创建硬链接 硬链接只有在同一个文件系统中才能创建 需要注意： 第一：ln 命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二：ln 的链接又分软链接和硬链接两种，软链接就是 ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。第三：ln 指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。 常用参数： -b 删除，覆盖以前建立的链接 -s 软链接（符号链接） -v 显示详细处理过程 实例： 给文件创建软链接，并显示操作信息 ln -sv source.log link.log 给文件创建硬链接，并显示操作信息 ln -v source.log link1.log 给目录创建软链接 ln -sv &#x2F;opt&#x2F;soft&#x2F;test&#x2F;test3 &#x2F;opt&#x2F;soft&#x2F;test&#x2F;test5 date显示或设定系统的日期与时间。 命令参数： -d&lt;字符串&gt; 显示字符串所指的日期与时间。字符串前后必须加上双引号。 -s&lt;字符串&gt; 根据字符串来设置日期与时间。字符串前后必须加上双引号。 -u 显示GMT。 %H 小时(00-23) %I 小时(00-12) %M 分钟(以00-59来表示) %s 总秒数。起算时间为1970-01-01 00:00:00 UTC。 %S 秒(以本地的惯用法来表示) %a 星期的缩写。 %A 星期的完整名称。 %d 日期(以01-31来表示)。 %D 日期(含年月日)。 %m 月份(以01-12来表示)。 %y 年份(以00-99来表示)。 %Y 年份(以四位数来表示)。 实例： 显示下一天 date +%Y%m%d --date&#x3D;&quot;+1 day&quot; #显示下一天的日期 -d 参数使用 date -d &quot;nov 22&quot; 今年的 11 月 22 日是星期三 date -d &#39;2 weeks&#39; 2周后的日期 date -d &#39;next monday&#39; (下周一的日期) date -d next-day +%Y%m%d（明天的日期）或者：date -d tomorrow +%Y%m%d date -d last-day +%Y%m%d(昨天的日期) 或者：date -d yesterday +%Y%m%d date -d last-month +%Y%m(上个月是几月) date -d next-month +%Y%m(下个月是几月) cal可以用户显示公历（阳历）日历如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份： 常用参数： -3 显示前一月，当前月，后一月三个月的日历 -m 显示星期一为第一列 -j 显示在当前年第几天 -y [year]显示当前年[year]份的日历 实例： 显示指定年月日期 cal 9 2012 显示 2013 年每个月日历 cal -y 2013 将星期一做为第一列,显示前中后三月 cal -3m grep强大的文本搜索命令，grep(Global Regular Expression Print) 全局正则表达式搜索。 grep 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。 命令格式： grep [option] pattern file|dir 常用参数： -A n --after-context显示匹配字符后n行 -B n --before-context显示匹配字符前n行 -C n --context 显示匹配字符前后n行 -c --count 计算符合样式的列数 -i 忽略大小写 -l 只列出文件内容符合指定的样式的文件名称 -f 从文件中读取关键词 -n 显示匹配内容的所在文件中行数 -R 递归查找文件夹 grep 的规则表达式: ^ #锚定行的开始 如：&#39;^grep&#39;匹配所有以grep开头的行。 $ #锚定行的结束 如：&#39;grep$&#39;匹配所有以grep结尾的行。 . #匹配一个非换行符的字符 如：&#39;gr.p&#39;匹配gr后接一个任意字符，然后是p。 * #匹配零个或多个先前字符 如：&#39;*grep&#39;匹配所有一个或多个空格后紧跟grep的行。 .* #一起用代表任意字符。 [] #匹配一个指定范围内的字符，如&#39;[Gg]rep&#39;匹配Grep和grep。 [^] #匹配一个不在指定范围内的字符，如：&#39;[^A-FH-Z]rep&#39;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。 \\(..\\) #标记匹配字符，如&#39;\\(love\\)&#39;，love被标记为1。 \\&lt; #锚定单词的开始，如:&#39;\\&lt;grep&#39;匹配包含以grep开头的单词的行。 \\&gt; #锚定单词的结束，如&#39;grep\\&gt;&#39;匹配包含以grep结尾的单词的行。 x\\&#123;m\\&#125; #重复字符x，m次，如：&#39;0\\&#123;5\\&#125;&#39;匹配包含5个o的行。 x\\&#123;m,\\&#125; #重复字符x,至少m次，如：&#39;o\\&#123;5,\\&#125;&#39;匹配至少有5个o的行。 x\\&#123;m,n\\&#125; #重复字符x，至少m次，不多于n次，如：&#39;o\\&#123;5,10\\&#125;&#39;匹配5--10个o的行。 \\w #匹配文字和数字字符，也就是[A-Za-z0-9]，如：&#39;G\\w*p&#39;匹配以G后跟零个或多个文字或数字字符，然后是p。 \\W #\\w的反置形式，匹配一个或多个非单词字符，如点号句号等。 \\b #单词锁定符，如: &#39;\\bgrep\\b&#39;只匹配grep。 实例： 查找指定进程 ps -ef | grep svn 查找指定进程个数 ps -ef | grep svn -c 从文件中读取关键词 cat test1.txt | grep -f key.log 从文件夹中递归查找以 grep 开头的行，并只列出文件 grep -lR &#39;^grep&#39; &#x2F;tmp 查找非 x 开关的行内容 grep &#39;^[^x]&#39; test.txt 显示包含 ed 或者 at 字符的内容行 grep -E &#39;ed|at&#39; test.txt wcwc(word count)功能为统计指定的文件中字节数、字数、行数，并将统计结果输出 命令格式： wc [option] file.. 命令参数： -c 统计字节数 -l 统计行数 -m 统计字符数 -w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串 实例： 查找文件的 行数 单词数 字节数 文件名 wc text.txt 结果： 7 8 70 test.txt 统计输出结果的行数 cat test.txt | wc -l psps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用 top linux 上进程有 5 种状态: 运行(正在运行或在运行队列中等待) 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) 僵死(进程已终止, 但进程描述符存在, 直到父进程调用 wait4()系统调用后释放) 停止(进程收到 SIGSTOP, SIGSTP, SIGTIN, SIGTOU 信号后停止运行运行) ps 工具标识进程的 5 种状态码: D 不可中断 uninterruptible sleep (usually IO) R 运行 runnable (on run queue) S 中断 sleeping T 停止 traced or stopped Z 僵死 a defunct (”zombie”) process 命令参数： -A 显示所有进程 a 显示所有进程 -a 显示同一终端下所有进程 c 显示进程真实名称 e 显示环境变量 f 显示进程间的关系 r 显示当前终端运行的进程 -aux 显示所有包含其它使用的进程 实例： 显示当前所有进程环境变量及进程间关系 ps -ef 显示当前所有进程 ps -A 与 grep 联用查找某进程 ps -aux | grep apache 找出与 cron 与 syslog 这两个服务有关的 PID 号码 ps aux | grep &#39;(cron|syslog)&#39; top显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等 常用参数： -c 显示完整的进程命令 -s 保密模式 -p &lt;进程号&gt; 指定进程显示 -n &lt;次数&gt;循环显示次数 实例： 1. top - 14:06:23 up 70 days, 16:44, 2 users, load average: 1.25, 1.32, 1.35 Tasks: 206 total, 1 running, 205 sleeping, 0 stopped, 0 zombie Cpu(s): 5.9%us, 3.4%sy, 0.0%ni, 90.4%id, 0.0%wa, 0.0%hi, 0.2%si, 0.0%st Mem: 32949016k total, 14411180k used, 18537836k free, 169884k buffers Swap: 32764556k total, 0k used, 32764556k free, 3612636k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 28894 root 22 0 1501m 405m 10m S 52.2 1.3 2534:16 java 前五行是当前系统情况整体的统计信息区。 第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下： 14:06:23 — 当前系统时间 up 70 days, 16:44 — 系统已经运行了70天16小时44分钟（在这期间系统没有重启过的吆！） 2 users — 当前有2个用户登录系统 load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。 load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。 第二行，Tasks — 任务（进程），具体信息说明如下： 系统现在共有206个进程，其中处于运行中的有1个，205个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。 第三行，cpu 状态信息，具体属性说明如下： 5.9%us — 用户空间占用CPU的百分比。 3.4% sy — 内核空间占用CPU的百分比。 0.0% ni — 改变过优先级的进程占用CPU的百分比 90.4% id — 空闲CPU百分比 0.0% wa — IO等待占用CPU的百分比 0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比 0.2% si — 软中断（Software Interrupts）占用CPU的百分比 备注：在这里 CPU 的使用比率和 windows 概念不同，需要理解 linux 系统用户空间和内核空间的相关知识！ 第四行，内存状态，具体信息如下： 32949016k total — 物理内存总量（32GB） 14411180k used — 使用中的内存总量（14GB） 18537836k free — 空闲内存总量（18GB） 169884k buffers — 缓存的内存量 （169M） 第五行，swap 交换分区信息，具体信息说明如下： 32764556k total — 交换区总量（32GB） 0k used — 使用的交换区总量（0K） 32764556k free — 空闲交换区总量（32GB） 3612636k cached — 缓冲的交换区总量（3.6GB） 第六行，空行。 第七行以下：各进程（任务）的状态监控，项目列信息说明如下： PID — 进程id USER — 进程所有者 PR — 进程优先级 NI — nice值。负值表示高优先级，正值表示低优先级 VIRT — 进程使用的虚拟内存总量，单位kb。VIRT&#x3D;SWAP+RES RES — 进程使用的、未被换出的物理内存大小，单位kb。RES&#x3D;CODE+DATA SHR — 共享内存大小，单位kb S — 进程状态。D&#x3D;不可中断的睡眠状态 R&#x3D;运行 S&#x3D;睡眠 T&#x3D;跟踪&#x2F;停止 Z&#x3D;僵尸进程 %CPU — 上次更新到现在的CPU时间占用百分比 %MEM — 进程使用的物理内存百分比 TIME+ — 进程使用的CPU时间总计，单位1&#x2F;100秒 COMMAND — 进程名称（命令名&#x2F;命令行） top 交互命令 h 显示top交互命令帮助信息 c 切换显示命令名称和完整命令行 m 以内存使用率排序 P 根据CPU使用百分比大小进行排序 T 根据时间&#x2F;累计时间进行排序 W 将当前设置写入~&#x2F;.toprc文件中 o或者O 改变显示项目的顺序 kill发送指定的信号到相应进程。不指定型号将发送 SIGTERM（15）终止指定进程。如果任无法终止该程序可用”-KILL” 参数，其发送的信号为 SIGKILL(9) ，将强制结束进程，使用 ps 命令或者 jobs 命令可以查看进程号。root 用户将影响用户的进程，非 root 用户只能影响自己的进程。 常用参数： -l 信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称 -a 当处理当前进程时，不限制命令名和进程号的对应关系 -p 指定kill 命令只打印相关进程的进程号，而不发送任何信号 -s 指定发送信号 -u 指定用户 实例： 先使用 ps 查找进程 pro1，然后用 kill 杀掉 kill -9 $(ps -ef | grep pro1) free显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。 命令参数： -b 以Byte显示内存使用情况 -k 以kb为单位显示内存使用情况 -m 以mb为单位显示内存使用情况 -g 以gb为单位显示内存使用情况 -s&lt;间隔秒数&gt; 持续显示内存 -t 显示内存使用总合 实例： 显示内存使用情况 free free -k free -m 以总和的形式显示内存的使用信息 free -t 周期性查询内存使用情况 free -s 10","raw":"---\ntitle: 常用的Linux命令\ndate: 2021-04-07\ntags: linux\ncategories: Linux\n---\n\n---\n\n# 常用的 linux 命令\n\n---\n\n<!--more-->\n\n# ls\n\n就是 list 的缩写，通过 ls 命令不仅可以查看 linux 文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。\n\n**常用参数搭配：**\n\n```shell\nls -a #列出目录所有文件，包含以.开始的隐藏文件\nls -A #列出除.及..的其它文件\nls -r #反序排列\nls -t #以文件修改时间排序\nls -S #以文件大小排序\nls -h #以易读大小显示\nls -l #除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来\n```\n\n**实例：**\n\n1. 按易读方式按时间反序排序，并显示文件详细信息\n\n```shell\nls -lhrt\n```\n\n2. 按大小反序显示文件详细信息\n\n```sh\nls -lrS\n```\n\n3. 列出当前目录中所有以\"t\"开头的目录的详细内容\n\n```sh\nls -l t*\n```\n\n4. 列出文件绝对路径（不包含隐藏文件）\n\n```sh\nls | sed \"s:^:`pwd`/:\"\n```\n\n5. 列出文件绝对路径（包含隐藏文件）\n\n```sh\nfind $pwd -maxdepth 1 | xargs ls -ld\n```\n\n# cd\n\ncd(changeDirectory) 命令语法：\n\n```shell\ncd [目录名]\n```\n\n说明：切换当前目录至 dirName。\n\n**实例：**\n\n1. 进入要目录\n\n```sh\ncd /\n```\n\n2. 进入 \"home\" 目录\n\n```sh\ncd ~\n```\n\n3. 进入上一次工作路径\n\n```sh\ncd -\n```\n\n4. 把上个命令的参数作为 cd 参数使用。\n\n```sh\ncd !$\n```\n\n# pwd\n\npwd 命令用于查看当前工作目录路径。\n\n**实例：**\n\n1. 查看当前路径\n\n```sh\npwd\n```\n\n2. 查看软链接的实际路径\n\n```sh\npwd -P\n```\n\n# mkdir\n\nmkdir 命令用于创建文件夹。\n\n**可用选项：**\n\n- -m: 对新建目录设置存取权限，也可以用 chmod 命令设置;\n- -p: 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后，系统将自动建立好那些尚不在的目录，即一次可以建立多个目录。\n\n**实例：**\n\n1. 当前工作目录下创建名为 t 的文件夹\n\n```sh\nmkdir t\n```\n\n2. 在 tmp 目录下创建路径为 test/t1/t 的目录，若不存在，则创建：\n\n```sh\nmkdir -p /tmp/test/t1/t\n```\n\n# rm\n\n删除一个目录中的一个或多个文件或目录，如果没有使用 -r 选项，则 rm 不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。\n\n```sh\nrm [选项] 文件…\n```\n\n**实例：**\n\n1. 删除任何 .log 文件，删除前逐一询问确认：\n\n```sh\nrm -i *.log\n```\n\n2. 删除 test 子目录及子目录中所有档案删除，并且不用一一确认：\n\n```sh\nrm -rf test\n```\n\n3. 删除以 -f 开头的文件\n\n```sh\nrm -- -f*\n```\n\n# rmdir\n\n从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。\n\n_注意：不能删除非空目录_\n\n**实例：**\n\n1. 当 parent 子目录被删除后使它也成为空目录的话，则顺便一并删除：\n\n```sh\nrmdir -p parent/child/child11\n```\n\n# mv\n\n移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。\n\n当第二个参数为目录时，第一个参数可以是多个以空格分隔的文件或目录，然后移动第一个参数指定的多个文件到第二个参数指定的目录中。\n\n**实例：**\n\n1. 将文件 test.log 重命名为 test1.txt\n\n```sh\nmv test.log test1.txt\n```\n\n2. 将文件 log1.txt,log2.txt,log3.txt 移动到根的 test3 目录中\n\n```sh\nmv llog1.txt log2.txt log3.txt /test3\n```\n\n3. 将文件 file1 改名为 file2，如果 file2 已经存在，则询问是否覆盖\n\n```sh\nmv -i log1.txt log2.txt\n```\n\n4. 移动当前文件夹下的所有文件到上一级目录\n\n```sh\nmv * ../\n```\n\n# cp\n\n将源文件复制至目标文件，或将多个源文件复制至目标目录。\n\n注意：命令行复制，如果目标文件已经存在会提示是否覆盖，而在 shell 脚本中，如果不加 -i 参数，则不会提示，而是直接覆盖！\n\n```sh\n-i #提示\n-r #复制目录及目录内所有项目\n-a #复制的文件与原文件时间一样\n```\n\n**实例：**\n\n1. 复制 a.txt 到 test 目录下，保持原文件时间，如果原文件存在提示是否覆盖。\n\n```sh\ncp -ai a.txt test\n```\n\n2. 为 a.txt 建议一个链接（快捷方式）\n\n```sh\ncp -s a.txt link_a.txt\n```\n\n# cat\n\ncat 主要有三大功能：\n\n1. 一次显示整个文件:\n\n```sh\ncat filename\n```\n\n2. 从键盘创建一个文件:\n\n```sh\ncat > filename\n```\n\n只能创建新文件，不能编辑已有文件。\n\n3. 将几个文件合并为一个文件:\n\n```sh\ncat file1 file2 > file\n```\n\n- -b 对非空输出行号\n- -n 输出所有行号\n\n**实例：**\n\n1. 把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里\n\n```sh\ncat -n log2012.log log2013.log\n```\n\n2. 把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里\n\n```sh\ncat -b log2012.log log2013.log log.log\n```\n\n3. 使用 here doc 生成新文件\n\n```sh\ncat >log.txt <<EOF\n>Hello\n>World\n>PWD=$(pwd)\n>EOF\nls -l log.txt\ncat log.txt\nHello\nWorld\nPWD=/opt/soft/test\n```\n\n4. 反向列示\n\n```sh\ntac log.txt\nPWD=/opt/soft/test\nWorld\nHello\n```\n\n# more\n\n功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。\n\n**命令参数：**\n\n```sh\n+n      #从笫 n 行开始显示\n-n       #定义屏幕大小为n行\n+/pattern #在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示\n-c       #从顶部清屏，然后显示\n-d       #提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能\n-l        #忽略Ctrl+l（换页）字符\n-p       #通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似\n-s       #把连续的多个空行显示为一行\n-u       #把文件内容中的下画线去掉\n```\n\n**常用操作命令：**\n\n```sh\nEnter    #向下 n 行，需要定义。默认为 1 行\nCtrl+F   #向下滚动一屏\n空格键  #向下滚动一屏\nCtrl+B  #返回上一屏\n=       #输出当前行的行号\n:f     #输出文件名和当前行的行号\nV      #调用vi编辑器\n!命令   #调用Shell，并执行命令\nq       #退出more\n```\n\n**实例：**\n\n1. 显示文件中从第 3 行起的内容\n\n```sh\nmore +3 text.txt\n```\n\n2. 在所列出文件目录详细信息，借助管道使每次显示 5 行\n\n```sh\nls -l | more -5\n```\n\n按空格显示下 5 行。\n\n# less\n\nless 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。\n\n**常用命令参数：**\n\n```sh\n-i  忽略搜索时的大小写\n-N  显示每行的行号\n-o  <文件名> 将less 输出的内容在指定文件中保存起来\n-s  显示连续空行为一行\n/字符串：向下搜索“字符串”的功能\n?字符串：向上搜索“字符串”的功能\nn：重复前一个搜索（与 / 或 ? 有关）\nN：反向重复前一个搜索（与 / 或 ? 有关）\n-x <数字> 将“tab”键显示为规定的数字空格\nb  向后翻一页\nd  向后翻半页\nh  显示帮助界面\nQ  退出less 命令\nu  向前滚动半页\ny  向前滚动一行\n空格键 滚动一行\n回车键 滚动一页\n[pagedown]： 向下翻动一页\n[pageup]：   向上翻动一页\n```\n\n**实例：**\n\n1. ps 查看进程信息并通过 less 分页显示\n\n```sh\nps -aux | less -N\n```\n\n2. 查看多个文件\n\n```sh\nless 1.log 2.log\n```\n\n可以使用 n 查看下一个，使用 p 查看前一个。\n\n# head\n\nhead 用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。\n\n**常用参数：**\n\n```sh\n-n<行数> 显示的行数（行数为复数表示从最后向前数）\n```\n\n**实例：**\n\n1. 显示 1.log 文件中前 20 行\n\n```sh\nhead 1.log -n 20\n```\n\n2. 显示 1.log 文件前 20 字节\n\n```sh\nhead -c 20 log2014.log\n```\n\n3. 显示 t.log 最后 10 行\n\n```sh\nhead -n -10 t.log\n```\n\n# tail\n\n用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。\n\n**常用参数：**\n\n```sh\n-f 循环读取（常用于查看递增的日志文件）\n-n<行数> 显示行数（从后向前）\n```\n\n1. 循环读取逐渐增加的文件内容\n\n```sh\nping 127.0.0.1 > ping.log &\n```\n\n后台运行：可使用 jobs -l 查看，也可使用 fg 将其移到前台运行。\n\n```sh\ntail -f ping.log\n（查看日志）\n```\n\n# which\n\n在 linux 要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：\n\n```sh\nwhich     查看可执行文件的位置。\nwhereis 查看文件的位置。\nlocate  配合数据库查看文件位置。\nfind        实际搜寻硬盘查询文件名称。\nwhich 是在 PATH 就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\n```\n\n**常用参数：**\n\n```sh\n-n 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。\n```\n\n**实例：**\n\n1. 查看 ls 命令是否存在，执行哪个\n\n```sh\nwhich ls\n```\n\n2. 查看 which\n\n```sh\nwhich which\n```\n\n3. 查看 cd\n\n```sh\nwhich cd（显示不存在，因为 cd 是内建命令，而 which 查找显示是 PATH 中的命令）\n```\n\n查看当前 PATH 配置：\n\n```sh\necho $PATH\n```\n\n或使用 env 查看所有环境变量及对应值\n\n# whereis\n\nwhereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man 说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。whereis 及 locate 都是基于系统内建的数据库进行搜索，因此效率很高，而 find 则是遍历硬盘查找文件。\n\n**常用参数：**\n\n```sh\n-b   定位可执行文件。\n-m   定位帮助文件。\n-s   定位源代码文件。\n-u   搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。\n```\n\n**实例：**\n\n1. 查找 locate 程序相关文件\n\n```sh\nwhereis locate\n```\n\n2. 查找 locate 的源码文件\n\n```sh\nwhereis -s locate\n```\n\n3. 查找 lcoate 的帮助文件\n\n```sh\nwhereis -m locate\n```\n\n# locate\n\nlocate 通过搜寻系统内建文档数据库达到快速找到档案，数据库由 updatedb 程序来更新，updatedb 是由 cron daemon 周期性调用的。默认情况下 locate 命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是 locate 所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb 每天会跑一次，可以由修改 crontab 来更新设定值 (etc/crontab)。\n\nlocate 与 find 命令相似，可以使用如 \\*、? 等进行正则匹配查找\n\n**常用参数：**\n\n```sh\n-l num（要显示的行数）\n-f   将特定的档案系统排除在外，如将proc排除在外\n-r   使用正则运算式做为寻找条件\n```\n\n**实例：**\n\n1. 查找和 pwd 相关的所有文件(文件名中包含 pwd）\n\n```sh\nlocate pwd\n```\n\n2. 搜索 etc 目录下所有以 sh 开头的文件\n\n```sh\nlocate /etc/sh\n```\n\n3. 查找 /var 目录下，以 reason 结尾的文件\n\n```sh\nlocate -r '^/var.*reason$'（其中.表示一个字符，*表示任务多个；.*表示任意多个字符）\n```\n\n# find\n\n用于在文件树中查找文件，并作出相应的处理。\n\n**命令格式：**\n\n```sh\nfind pathname -options [-print -exec -ok ...]\n```\n\n**命令参数：**\n\n```sh\npathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。\n-print： find命令将匹配的文件输出到标准输出。\n-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' {  } \\;，注意{   }和\\；之间的空格。\n-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。\n```\n\n**命令选项：**\n\n```sh\n-name 按照文件名查找文件\n-perm 按文件权限查找文件\n-user 按文件属主查找文件\n-group  按照文件所属的组来查找文件。\n-type  查找某一类型的文件，诸如：\n   b - 块设备文件\n   d - 目录\n   c - 字符设备文件\n   l - 符号链接文件\n   p - 管道文件\n   f - 普通文件\n\n-size n :[c] 查找文件长度为n块文件，带有c时表文件字节大小\n-amin n   查找系统中最后N分钟访问的文件\n-atime n  查找系统中最后n*24小时访问的文件\n-cmin n   查找系统中最后N分钟被改变文件状态的文件\n-ctime n  查找系统中最后n*24小时被改变文件状态的文件\n-mmin n   查找系统中最后N分钟被改变文件数据的文件\n-mtime n  查找系统中最后n*24小时被改变文件数据的文件\n(用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。 )\n-maxdepth n 最大查找目录深度\n-prune 选项来指出需要忽略的目录。在使用-prune选项时要当心，因为如果你同时使用了-depth选项，那么-prune选项就会被find命令忽略\n-newer 如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项\n```\n\n**实例：**\n\n1. 查找 48 小时内修改过的文件\n\n```sh\nfind -atime -2\n```\n\n2. 在当前目录查找 以 .log 结尾的文件。 . 代表当前目录\n\n```sh\nfind ./ -name '*.log'\n```\n\n3. 查找 /opt 目录下 权限为 777 的文件\n\n```sh\nfind /opt -perm 777\n```\n\n4. 查找大于 1K 的文件\n\n```sh\nfind -size +1000c\n```\n\n查找等于 1000 字符的文件\n\n```sh\nfind -size 1000c\n-exec 参数后面跟的是 command 命令，它的终止是以 ; 为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面find查找出来的文件名。\n```\n\n**实例：**\n\n5. 在当前目录中查找更改时间在 10 日以前的文件并删除它们(无提醒）\n\n```sh\nfind . -type f -mtime +10 -exec rm -f {} \\;\n```\n\n6. 当前目录中查找所有文件名以.log 结尾、更改时间在 5 日以上的文件，并删除它们，只不过在删除之前先给出提示。 按 y 键删除文件，按 n 键不删除\n\n```sh\nfind . -name '*.log' mtime +5 -ok -exec rm {} \\;\n```\n\n7. 当前目录下查找文件名以 passwd 开头，内容包含 \"pkg\" 字符的文件\n\n```sh\nfind . -f -name 'passwd*' -exec grep \"pkg\" {} \\;\n```\n\n8. 用 exec 选项执行 cp 命令\n\n```sh\nfind . -name '*.log' -exec cp {} test3 \\;\n-xargs find 命令把匹配到的文件传递给 xargs 命令，而 xargs 命令每次只获取一部分文件而不是全部，不像 -exec 选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。\n```\n\n**实例：**\n\n9. 查找当前目录下每个普通文件，然后使用 xargs 来判断文件类型\n\n```sh\nfind . -type f -print | xargs file\n```\n\n10. 查找当前目录下所有以 js 结尾的并且其中包含 'editor' 字符的普通文件\n\n```sh\nfind . -type f -name \"*.js\" -exec grep -lF 'ueditor' {} \\;\nfind -type f -name '*.js' | xargs grep -lF 'editor'\n```\n\n11. 利用 xargs 执行 mv 命令\n\n```sh\nfind . -name \"*.log\" | xargs -i mv {} test4\n```\n\n12. 用 grep 命令在当前目录下的所有普通文件中搜索 hostnames 这个词，并标出所在行：\n\n```sh\nfind . -name \\*(转义） -type f -print | xargs grep -n 'hostnames'\n```\n\n13. 查找当前目录中以一个小写字母开头，最后是 4 到 9 加上 .log 结束的文件：\n\n```sh\nfind . -name '[a-z]*[4-9].log' -print\n```\n\n14. 在 test 目录查找不在 test4 子目录查找\n\n```sh\nfind test -path 'test/test4' -prune -o -print\n```\n\n15. 实例 1：查找更改时间比文件 log2012.log 新但比文件 log2017.log 旧的文件\n\n```sh\nfind -newer log2012.log ! -newer log2017.log\n```\n\n**使用 depth 选项：**\n\ndepth 选项可以使 find 命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件。\n\n实例：find 命令从文件系统的根目录开始，查找一个名为 CON.FILE 的文件。 它将首先匹配所有的文件然后再进入子目录中查找\n\n```sh\nfind / -name \"CON.FILE\" -depth -print\n```\n\n# chmod\n\n用于改变 linux 系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。\n\n每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。可使用 ls -l test.txt 查找。\n\n以文件 log2012.log 为例：\n\n```sh\n-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log\n```\n\n第一列共有 10 个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是 d，表示是一个目录。从第二个字符开始到第十个 9 个字符，3 个字符一组，分别表示了 3 组用户对文件或者目录的权限。权限字符用横线代表空许可，r 代表只读，w 代表写，x 代表可执行。\n\n**常用参数：**\n\n```sh\n-c 当发生改变时，报告处理信息\n-R 处理指定目录以及其子目录下所有文件\n```\n\n**权限范围：**\n\n```sh\nu ：目录或者文件的当前的用户\ng ：目录或者文件的当前的群组\no ：除了目录或者文件的当前用户或群组之外的用户或者群组\na ：所有的用户及群组\n```\n\n**权限代号：**\n\n```sh\nr ：读权限，用数字4表示\nw ：写权限，用数字2表示\nx ：执行权限，用数字1表示\n- ：删除权限，用数字0表示\ns ：特殊权限\n```\n\n**实例：**\n\n1. 增加文件 t.log 所有用户可执行权限\n\n```sh\nchmod a+x t.log\n```\n\n2. 撤销原来所有的权限，然后使拥有者具有可读权限,并输出处理信息\n\n```sh\nchmod u=r t.log -c\n```\n\n3. 给 file 的属主分配读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限\n\n```sh\nchmod 751 t.log -c（或者：chmod u=rwx,g=rx,o=x t.log -c)\n```\n\n4. 将 test 目录及其子目录所有文件添加可读权限\n\n```sh\nchmod u+r,g+r,o+r -R text/ -c19、tar 命令\n```\n\n用来压缩和解压文件。tar 本身不具有压缩功能，只具有打包功能，有关压缩及解压是调用其它的功能来完成。\n\n_弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件_\n\n**常用参数：**\n\n```sh\n-c 建立新的压缩文件\n-f 指定压缩文件\n-r 添加文件到已经压缩文件包中\n-u 添加改了和现有的文件到压缩包中\n-x 从压缩包中抽取文件\n-t 显示压缩文件中的内容\n-z 支持gzip压缩\n-j 支持bzip2压缩\n-Z 支持compress解压文件\n-v 显示操作过程\n```\n\n**有关 gzip 及 bzip2 压缩:**\n\n```sh\ngzip 实例：压缩 gzip fileName .tar.gz 和.tgz  解压：gunzip filename.gz 或 gzip -d filename.gz\n          对应：tar zcvf filename.tar.gz     tar zxvf filename.tar.gz\n\nbz2实例：压缩 bzip2 -z filename .tar.bz2 解压：bunzip filename.bz2或bzip -d filename.bz2\n       对应：tar jcvf filename.tar.gz         解压：tar jxvf filename.tar.bz2\n```\n\n**实例：**\n\n1. 将文件全部打包成 tar 包\n\n```sh\ntar -cvf log.tar 1.log,2.log 或tar -cvf log.*\n```\n\n2. 将 /etc 下的所有文件及目录打包到指定目录，并使用 gz 压缩\n\n```sh\ntar -zcvf /tmp/etc.tar.gz /etc\n```\n\n3. 查看刚打包的文件内容（一定加 z，因为是使用 gzip 压缩的）\n\n```sh\ntar -ztvf /tmp/etc.tar.gz\n```\n\n4. 要压缩打包 /home, /etc ，但不要 /home/dmtsai\n\n```sh\ntar --exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc\n```\n\n# chown\n\nchown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID；组可以是组名或者组 ID；文件是以空格分开的要改变权限的文件列表，支持通配符。\n\n```sh\n-c 显示更改的部分的信息\n-R 处理指定目录及子目录\n```\n\n**实例：**\n\n1. 改变拥有者和群组 并显示改变信息\n\n```sh\nchown -c mail:mail log2012.log\n```\n\n2. 改变文件群组\n\n```sh\nchown -c :mail t.log\n```\n\n3. 改变文件夹及子文件目录属主及属组为 mail\n\n```sh\nchown -cR mail: test/\n```\n\n# df\n\n显示磁盘空间使用情况。获取硬盘被占用了多少空间，目前还剩下多少空间等信息，如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以 512 字节为单位进行显示：\n\n```sh\n-a 全部文件系统列表\n-h 以方便阅读的方式显示信息\n-i 显示inode信息\n-k 区块为1024字节\n-l 只显示本地磁盘\n-T 列出文件系统类型\n```\n\n**实例：**\n\n1. 显示磁盘使用情况\n\n```sh\ndf -l\n```\n\n2. 以易读方式列出所有文件系统及其类型\n\n```sh\ndf -haT\n```\n\n# du\n\ndu 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看：\n\n**命令格式：**\n\n```sh\ndu [选项] [文件]\n```\n\n**常用参数：**\n\n```sh\n-a 显示目录中所有文件大小\n-k 以KB为单位显示文件大小\n-m 以MB为单位显示文件大小\n-g 以GB为单位显示文件大小\n-h 以易读方式显示文件大小\n-s 仅显示总计\n-c或--total  除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和\n```\n\n**实例：**\n\n1. 以易读方式显示文件夹内及子文件夹大小\n\n```sh\ndu -h scf/\n```\n\n2. 以易读方式显示文件夹内所有文件大小\n\n```sh\ndu -ah scf/\n```\n\n3. 显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和\n\n```sh\ndu -hc test/ scf/\n```\n\n4. 输出当前目录下各个子目录所使用的空间\n\n```sh\ndu -hc --max-depth=1 scf/\n```\n\n# ln\n\n功能是为文件在另外一个位置建立一个同步的链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过 ln 创建的链接（link）减少磁盘占用量。\n\n_链接分类：软件链接及硬链接_\n\n**软链接：**\n\n1. 软链接，以路径的形式存在。类似于 Windows 操作系统中的快捷方式\n2. 软链接可以 跨文件系统 ，硬链接不可以\n3. 软链接可以对一个不存在的文件名进行链接\n4. 软链接可以对目录进行链接\n\n**硬链接:**\n\n1. 硬链接，以文件副本的形式存在。但不占用实际空间。\n2. 不允许给目录创建硬链接\n3. 硬链接只有在同一个文件系统中才能创建\n\n**需要注意：**\n\n第一：ln 命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；\n第二：ln 的链接又分软链接和硬链接两种，软链接就是 ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。\n第三：ln 指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。\n\n**常用参数：**\n\n```sh\n-b 删除，覆盖以前建立的链接\n-s 软链接（符号链接）\n-v 显示详细处理过程\n```\n\n**实例：**\n\n1. 给文件创建软链接，并显示操作信息\n\n```sh\nln -sv source.log link.log\n```\n\n2. 给文件创建硬链接，并显示操作信息\n\n```sh\nln -v source.log link1.log\n```\n\n3. 给目录创建软链接\n\n```sh\nln -sv /opt/soft/test/test3 /opt/soft/test/test5\n```\n\n# date\n\n显示或设定系统的日期与时间。\n\n**命令参数：**\n\n```sh\n-d<字符串> 　显示字符串所指的日期与时间。字符串前后必须加上双引号。\n-s<字符串> 　根据字符串来设置日期与时间。字符串前后必须加上双引号。\n-u 　显示GMT。\n%H 小时(00-23)\n%I 小时(00-12)\n%M 分钟(以00-59来表示)\n%s 总秒数。起算时间为1970-01-01 00:00:00 UTC。\n%S 秒(以本地的惯用法来表示)\n%a 星期的缩写。\n%A 星期的完整名称。\n%d 日期(以01-31来表示)。\n%D 日期(含年月日)。\n%m 月份(以01-12来表示)。\n%y 年份(以00-99来表示)。\n%Y 年份(以四位数来表示)。\n```\n\n**实例：**\n\n1. 显示下一天\n\n```sh\ndate +%Y%m%d --date=\"+1 day\"  #显示下一天的日期\n```\n\n2. -d 参数使用\n\n```sh\ndate -d \"nov 22\"  今年的 11 月 22 日是星期三\ndate -d '2 weeks' 2周后的日期\ndate -d 'next monday' (下周一的日期)\ndate -d next-day +%Y%m%d（明天的日期）或者：date -d tomorrow +%Y%m%d\ndate -d last-day +%Y%m%d(昨天的日期) 或者：date -d yesterday +%Y%m%d\ndate -d last-month +%Y%m(上个月是几月)\ndate -d next-month +%Y%m(下个月是几月)\n```\n\n# cal\n\n可以用户显示公历（阳历）日历如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份：\n\n**常用参数：**\n\n```sh\n-3 显示前一月，当前月，后一月三个月的日历\n-m 显示星期一为第一列\n-j 显示在当前年第几天\n-y [year]显示当前年[year]份的日历\n```\n\n**实例：**\n\n1. 显示指定年月日期\n\n```sh\ncal 9 2012\n```\n\n2. 显示 2013 年每个月日历\n\n```sh\ncal -y 2013\n```\n\n3. 将星期一做为第一列,显示前中后三月\n\n```sh\ncal -3m\n```\n\n# grep\n\n强大的文本搜索命令，grep(Global Regular Expression Print) 全局正则表达式搜索。\n\ngrep 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。\n\n**命令格式：**\n\n```sh\ngrep [option] pattern file|dir\n```\n\n**常用参数：**\n\n```sh\n-A n --after-context显示匹配字符后n行\n-B n --before-context显示匹配字符前n行\n-C n --context 显示匹配字符前后n行\n-c --count 计算符合样式的列数\n-i 忽略大小写\n-l 只列出文件内容符合指定的样式的文件名称\n-f 从文件中读取关键词\n-n 显示匹配内容的所在文件中行数\n-R 递归查找文件夹\n```\n\n**grep 的规则表达式:**\n\n```sh\n^  #锚定行的开始 如：'^grep'匹配所有以grep开头的行。\n$  #锚定行的结束 如：'grep$'匹配所有以grep结尾的行。\n.  #匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。\n*  #匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。\n.*   #一起用代表任意字符。\n[]   #匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。\n[^]  #匹配一个不在指定范围内的字符，如：'[^A-FH-Z]rep'匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。\n\\(..\\)  #标记匹配字符，如'\\(love\\)'，love被标记为1。\n\\<      #锚定单词的开始，如:'\\<grep'匹配包含以grep开头的单词的行。\n\\>      #锚定单词的结束，如'grep\\>'匹配包含以grep结尾的单词的行。\nx\\{m\\}  #重复字符x，m次，如：'0\\{5\\}'匹配包含5个o的行。\nx\\{m,\\}  #重复字符x,至少m次，如：'o\\{5,\\}'匹配至少有5个o的行。\nx\\{m,n\\}  #重复字符x，至少m次，不多于n次，如：'o\\{5,10\\}'匹配5--10个o的行。\n\\w    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。\n\\W    #\\w的反置形式，匹配一个或多个非单词字符，如点号句号等。\n\\b    #单词锁定符，如: '\\bgrep\\b'只匹配grep。\n```\n\n**实例：**\n\n1. 查找指定进程\n\n```sh\nps -ef | grep svn\n```\n\n2. 查找指定进程个数\n\n```sh\nps -ef | grep svn -c\n```\n\n3. 从文件中读取关键词\n\n```sh\ncat test1.txt | grep -f key.log\n```\n\n4. 从文件夹中递归查找以 grep 开头的行，并只列出文件\n\n```sh\ngrep -lR '^grep' /tmp\n```\n\n5. 查找非 x 开关的行内容\n\n```sh\ngrep '^[^x]' test.txt\n```\n\n6. 显示包含 ed 或者 at 字符的内容行\n\n```sh\ngrep -E 'ed|at' test.txt\n```\n\n# wc\n\nwc(word count)功能为统计指定的文件中字节数、字数、行数，并将统计结果输出\n\n**命令格式：**\n\n```sh\nwc [option] file..\n```\n\n**命令参数：**\n\n```sh\n-c 统计字节数\n-l 统计行数\n-m 统计字符数\n-w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串\n```\n\n**实例：**\n\n1. 查找文件的 行数 单词数 字节数 文件名\n\n```sh\nwc text.txt\n```\n\n结果：\n\n```sh\n7     8     70     test.txt\n```\n\n2. 统计输出结果的行数\n\n```sh\ncat test.txt | wc -l\n```\n\n# ps\n\nps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用 top\n\n_linux 上进程有 5 种状态:_\n\n1. 运行(正在运行或在运行队列中等待)\n2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)\n3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)\n4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用 wait4()系统调用后释放)\n5. 停止(进程收到 SIGSTOP, SIGSTP, SIGTIN, SIGTOU 信号后停止运行运行)\n\n_ps 工具标识进程的 5 种状态码:_\n\n```sh\nD 不可中断 uninterruptible sleep (usually IO)\nR 运行 runnable (on run queue)\nS 中断 sleeping\nT 停止 traced or stopped\nZ 僵死 a defunct (”zombie”) process\n```\n\n**命令参数：**\n\n```sh\n-A 显示所有进程\na 显示所有进程\n-a 显示同一终端下所有进程\nc 显示进程真实名称\ne 显示环境变量\nf 显示进程间的关系\nr 显示当前终端运行的进程\n-aux 显示所有包含其它使用的进程\n```\n\n**实例：**\n\n1. 显示当前所有进程环境变量及进程间关系\n\n```sh\nps -ef\n```\n\n2. 显示当前所有进程\n\n```sh\nps -A\n```\n\n3. 与 grep 联用查找某进程\n\n```sh\nps -aux | grep apache\n```\n\n4. 找出与 cron 与 syslog 这两个服务有关的 PID 号码\n\n```sh\nps aux | grep '(cron|syslog)'\n```\n\n# top\n\n显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等\n\n**常用参数：**\n\n```sh\n-c 显示完整的进程命令\n-s 保密模式\n-p <进程号> 指定进程显示\n-n <次数>循环显示次数\n```\n\n**实例：**\n\n1.\n\n```sh\ntop - 14:06:23 up 70 days, 16:44,  2 users,  load average: 1.25, 1.32, 1.35\nTasks: 206 total,   1 running, 205 sleeping,   0 stopped,   0 zombie\nCpu(s):  5.9%us,  3.4%sy,  0.0%ni, 90.4%id,  0.0%wa,  0.0%hi,  0.2%si,  0.0%st\nMem:  32949016k total, 14411180k used, 18537836k free,   169884k buffers\nSwap: 32764556k total,        0k used, 32764556k free,  3612636k cached\nPID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND\n28894 root      22   0 1501m 405m  10m S 52.2  1.3   2534:16 java\n```\n\n前五行是当前系统情况整体的统计信息区。\n\n- 第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：\n\n```sh\n14:06:23 — 当前系统时间\n\nup 70 days, 16:44 — 系统已经运行了70天16小时44分钟（在这期间系统没有重启过的吆！）\n\n2 users — 当前有2个用户登录系统\n\nload average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。\n\nload average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。\n```\n\n- 第二行，Tasks — 任务（进程），具体信息说明如下：\n\n```sh\n系统现在共有206个进程，其中处于运行中的有1个，205个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。\n```\n\n- 第三行，cpu 状态信息，具体属性说明如下：\n\n```sh\n5.9%us — 用户空间占用CPU的百分比。\n3.4% sy — 内核空间占用CPU的百分比。\n0.0% ni — 改变过优先级的进程占用CPU的百分比\n90.4% id — 空闲CPU百分比\n0.0% wa — IO等待占用CPU的百分比\n0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比\n0.2% si — 软中断（Software Interrupts）占用CPU的百分比\n```\n\n备注：在这里 CPU 的使用比率和 windows 概念不同，需要理解 linux 系统用户空间和内核空间的相关知识！\n\n- 第四行，内存状态，具体信息如下：\n\n```sh\n32949016k total — 物理内存总量（32GB）\n14411180k used — 使用中的内存总量（14GB）\n18537836k free — 空闲内存总量（18GB）\n169884k buffers — 缓存的内存量 （169M）\n```\n\n- 第五行，swap 交换分区信息，具体信息说明如下：\n\n```sh\n32764556k total — 交换区总量（32GB）\n0k used — 使用的交换区总量（0K）\n32764556k free — 空闲交换区总量（32GB）\n3612636k cached — 缓冲的交换区总量（3.6GB）\n```\n\n- 第六行，空行。\n\n- 第七行以下：各进程（任务）的状态监控，项目列信息说明如下：\n\n```sh\nPID — 进程id\nUSER — 进程所有者\nPR — 进程优先级\nNI — nice值。负值表示高优先级，正值表示低优先级\nVIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES\nRES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA\nSHR — 共享内存大小，单位kb\nS — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程\n%CPU — 上次更新到现在的CPU时间占用百分比\n%MEM — 进程使用的物理内存百分比\nTIME+ — 进程使用的CPU时间总计，单位1/100秒\nCOMMAND — 进程名称（命令名/命令行）\n```\n\n**top 交互命令**\n\n```sh\nh 显示top交互命令帮助信息\nc 切换显示命令名称和完整命令行\nm 以内存使用率排序\nP 根据CPU使用百分比大小进行排序\nT 根据时间/累计时间进行排序\nW 将当前设置写入~/.toprc文件中\no或者O 改变显示项目的顺序\n```\n\n# kill\n\n发送指定的信号到相应进程。不指定型号将发送 SIGTERM（15）终止指定进程。如果任无法终止该程序可用\"-KILL\" 参数，其发送的信号为 SIGKILL(9) ，将强制结束进程，使用 ps 命令或者 jobs 命令可以查看进程号。root 用户将影响用户的进程，非 root 用户只能影响自己的进程。\n\n**常用参数：**\n\n```sh\n-l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称\n-a  当处理当前进程时，不限制命令名和进程号的对应关系\n-p  指定kill 命令只打印相关进程的进程号，而不发送任何信号\n-s  指定发送信号\n-u  指定用户\n```\n\n**实例：**\n\n1. 先使用 ps 查找进程 pro1，然后用 kill 杀掉\n\n```sh\nkill -9 $(ps -ef | grep pro1)\n```\n\n# free\n\n显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。\n\n**命令参数：**\n\n```sh\n-b 以Byte显示内存使用情况\n-k 以kb为单位显示内存使用情况\n-m 以mb为单位显示内存使用情况\n-g 以gb为单位显示内存使用情况\n-s<间隔秒数> 持续显示内存\n-t 显示内存使用总合\n```\n\n**实例：**\n\n1. 显示内存使用情况\n\n```sh\nfree\nfree -k\nfree -m\n```\n\n2. 以总和的形式显示内存的使用信息\n\n```sh\nfree -t\n```\n\n3. 周期性查询内存使用情况\n\n```sh\nfree -s 10\n```\n","tags":[{"name":"linux","slug":"linux","permalink":"https://xuyuquan0713.github.io/tags/linux/"}]},{"title":"网站分享","date":"2021-04-04T11:05:03.000Z","path":"2021/04/04/网站分享/","text":"实用网站分享 搞学习 CSDN：https://www.csdn.net/ TED（最优质的演讲）： https://www.ted.com/ 谷粉学术：https://gfsoso.99lb.net/scholar.html 大学资源网：http://www.dxzy163.com/ 简答题：http://www.jiandati.com/ 网易公开课：https://open.163.com/ted/ 网易云课堂：https://study.163.com/ 中国大学 MOOC：www.icourse163.org 哔哩哔哩弹幕网：www.bilibili.com 我要自学网：www.51zxw.net 知乎：www.zhihu.com 学堂在线：www.xuetangx.com 爱课程：www.icourses.cn 猫咪论文：https://lunwen.im/ iData（论文搜索）：www.cn-ki.net 文泉考试：https://www.wqkaoshi.com 找书籍 书栈网（极力推荐）：https://www.bookstack.cn/ 码农之家（计算机电子书下载）：www.xz577.com 鸠摩搜书：www.jiumodiary.com 云海电子图书馆：www.pdfbook.cn 周读（书籍搜索）：ireadweek.com 知轩藏书：http://www.zxcs.me/ 脚本之家电子书下载：https://www.jb51.net/books/ 搜书 VIP-电子书搜索：http://www.soshuvip.com/all.html 书格（在线古籍图书馆）：https://new.shuge.org/ caj 云阅读：http://cajviewer.cnki.net/cajcloud/ 必看网（人生必看的书籍）：https://www.biikan.com/ 冷知识 / 黑科技 上班摸鱼必备（假装电脑系统升级）：http://fakeupdate.net/ PIECES 拼图（30 个 CSS 碎片进行拼图，呈现 30 种濒临灭绝的动物）：http://www.species-in-pieces.com/ 图片立体像素画：https://pissang.github.io/voxelize-image/ 福利单词（一个不太正经的背单词网站）：http://dict.ftqq.com 查无此人（刷新网站，展现一张 AI 生成的人脸照片）：https://thispersondoesnotexist.com/ 在线制作地图图例：https://mapchart.net/ 创意光线绘画：http://weavesilk.com/ 星系观察：https://stellarium-web.org/ 煎蛋：http://jandan.net/ 渣男-说话的艺术：https://lovelive.tools/ 全历史：https://www.allhistory.com/ iData：https://www.cn-ki.net/ 术语在线：http://www.termonline.cn/ 写代码 GitHub：https://github.com/ 码云：https://gitee.com/ 源码之家：https://www.mycodes.net/ JSON to Dart： https://javiercbk.github.io/json\\_to\\_dart/ Json 在线解析验证： https://www.json.cn/ 在线接口测试（Getman）： https://getman.cn/ 资源搜索 DogeDoge 搜索引擎：www.dogedoge.com 秘迹搜索：https://mijisou.com/ 小白盘：https://www.xiaobaipan.com/ 云盘精灵（资源搜索）： www.yunpanjingling.com 虫部落（资源搜索）： www.chongbuluo.com 如风搜（资源搜索）： http://www.rufengso.net/ 爱扒：https://www.zyboe.com/ 小工具 奶牛快传（在线传输文件利器）：cowtransfer.com 文叔叔（大文件传输，不限速）： https://www.wenshushu.cn/ 云端超级应用空间（PS，PPT，Excel，Ai）：https://uzer.me/ 香当网（年终总结，个人简历，事迹材料，租赁合同，演讲稿）： https://www.xiangdang.net/ 二维码生成：https://cli.im/ 搜狗翻译：fanyi.sogou.com 熵数（图表制作，数据可视化）： https://dydata.io/appv2/#/pages/index/home 拷贝兔：https://cp.anyknew.com/ 图片无限变放大：http://bigjpg.com/zh 幕布（在线大纲笔记工具）：mubu.com 在线转换器（在线转换器转换任何测量单位）：https://zh.justcnw.com/ 调查问卷制作： https://www.wenjuan.com/ 果核剥壳（软件下载）： https://www.ghpym.com/ 软件下载：https://www.unyoo.com/ MSDN 我告诉你（windows10 系统镜像下载）：https://msdn.itellyou.cn/ 导航页（工具集） 世界各国网址大全：http://www.world68.com/ 小森林导航：http://www.xsldh6.com/ 简捷工具：http://www.shulijp.com/ NiceTool.net 好工具网：http://www.nicetool.net/ 现实君工具箱（综合型在线工具集成网站）：http://tool.uixsj.cn/ 蓝调网站：http://lcoc.top/ 偷渡鱼：https://touduyu.com/ 牛导航：http://www.ziliao6.com/ 小呆导航：https://www.webjike.com/index.html 简法主页：http://www.jianfast.com/ KIM 主页：https://kim.plopco.com/ 聚 BT：https://jubt.net/cn/index.html 精准云工具合集：https://jingzhunyun.com/ 兔 2 工具合集：https://www.tool2.cn/ 爱资料工具（在线实用工具集合）：www.toolnb.com 工具导航：https://hao.logosc.cn/ 看视频 阿木影视：https://www.aosk.online/ 电影推荐（分类别致）：http://www.mvcat.com APP 影院：https://app.movie 去看 TV：https://www.qukantv.net/ 动漫视频网：http://www.zzzfun.com/ 94 神马电影网：http://www.9rmb.com/ NO 视频官网：http://www.novipnoad.com/ 蓝光画质电影：http://www.languang.co/ 在线看剧：http://dy.27234.cn/ 大数据导航：http://hao.199it.com/ 多功能图片网站：https://www.logosc.cn/so/ 牛牛 TV：http://www.ziliao6.com/tv/ VideoFk 解析视频：http://www.videofk.com/ 蓝调网站：http://lcoc.top/vip2.3/ 永久资源采集网：http://www.yongjiuzy1.com/ 学设计 码力全开（产品/设计师/独立开发者的资源库）：https://www.maliquankai.com/designnav/ 免费音频素材：https://icons8.cn/music 新 CG 儿（视频素材模板，无水印+免费下载）：https://www.newcger.com/ Iconfont（阿里巴巴矢量图标库）：https://www.iconfont.cn/ 小图标下载：https://www.easyicon.net/ Flight Icon：https://www.flighticon.co/ 第一字体转换器：http://www.diyiziti.com/ doyoudosh（平面设计）：www.doyoudo.com 企业宣传视频在线制作：https://duomu.tv/ MAKE 海报设计官网：http://maka.im/ 一键海报神器：https://www.logosc.cn/photo/utm\\_source=hao.logosc.cn&amp;utm\\_medium=referral 字由（字体设计）：http://www.hellofont.cn/ 查字体网站：https://fonts.safe.360.cn/ 爱给网（免费素材下载的网站，包括音效、配乐，3D、视频、游戏，平面、教程）：http://www.aigei.com/ 在线视频剪辑：https://bilibili.clipchamp.com/editor 搞文档 即书（在线制作 PPT）：https://www.keysuper.com/ PDF 处理：https://smallpdf.com/cn PDF 处理：https://www.ilovepdf.com/zh-cn PDF 处理：https://www.pdfpai.com/ PDF 处理：https://www.hipdf.cn/ 图片压缩，PDF 处理：https://docsmall.com/ 腾讯文档（在线协作编辑和管理文档）：docs.qq.com ProcessOn（在线协作制作结构图）：www.processon.com iLovePDF（在线转换 PDF 利器）：www.ilovepdf.com PPT 在线制作：https://www.woodo.cn/ PDF24 工具（pdf 处理工具）：https://tools.pdf24.org/en IMGBOT（在线图片处理）：www.imgbot.ai 福昕云编辑（在线编辑 PDF）：edit.foxitcloud.cn TinyPNG（在线压缩图片）：tinypng.com UZER.ME（在线使用各种大应用，在线使用 CAD，MATLAB，Office 三件套 ）：uzer.me 优品 PPT（模板下载）：http://www.ypppt.com/ 第一 PPT（模板下载）：http://www.1ppt.com/xiazai/ 三顿 PPT 导航：sandunppt.com Excel 函数表：https://support.office.com/zh-cn/article/excel-%E5%87%BD%E6%95%B0%EF%BC%88%E6%8C%89%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%EF%BC%89-b3944572-255d-4efb-bb96-c6d90033e188 找图片 电脑壁纸：http://lcoc.top/bizhi/ https://unsplash.com/ https://pixabay.com/ https://www.pexels.com/ https://visualhunt.com/ https://www.ssyer.com/ 彼岸图网：http://pic.netbian.com/ 极像素（超高清大图）：https://www.sigoo.com/ 免费版权图片搜索：https://www.logosc.cn/so/","raw":"---\nlayout: source\ntitle: 网站分享\ndate: 2021-04-04 19:05:03\ntags: 网站\ncategories: 分享\n\n---\n\n---\n\n# 实用网站分享\n\n---\n\n<!--more-->\n\n## 搞学习\n\n- CSDN：https://www.csdn.net/\n- TED（最优质的演讲）：\n- https://www.ted.com/\n- 谷粉学术：https://gfsoso.99lb.net/scholar.html\n- 大学资源网：http://www.dxzy163.com/\n- 简答题：http://www.jiandati.com/\n- 网易公开课：https://open.163.com/ted/\n- 网易云课堂：https://study.163.com/\n- 中国大学 MOOC：www.icourse163.org\n- 哔哩哔哩弹幕网：www.bilibili.com\n- 我要自学网：www.51zxw.net\n- 知乎：www.zhihu.com\n- 学堂在线：www.xuetangx.com\n- 爱课程：www.icourses.cn\n- 猫咪论文：https://lunwen.im/\n- iData（论文搜索）：www.cn-ki.net\n- 文泉考试：https://www.wqkaoshi.com\n\n## 找书籍\n\n- 书栈网（极力推荐）：https://www.bookstack.cn/\n- 码农之家（计算机电子书下载）：www.xz577.com\n- 鸠摩搜书：www.jiumodiary.com\n- 云海电子图书馆：www.pdfbook.cn\n- 周读（书籍搜索）：ireadweek.com\n- 知轩藏书：http://www.zxcs.me/\n- 脚本之家电子书下载：https://www.jb51.net/books/\n- 搜书 VIP-电子书搜索：http://www.soshuvip.com/all.html\n- 书格（在线古籍图书馆）：https://new.shuge.org/\n- caj 云阅读：http://cajviewer.cnki.net/cajcloud/\n- 必看网（人生必看的书籍）：https://www.biikan.com/\n\n## 冷知识 / 黑科技\n\n- 上班摸鱼必备（假装电脑系统升级）：http://fakeupdate.net/ PIECES 拼图（30 个 CSS 碎片进行拼图，呈现 30 种濒临灭绝的动物）：http://www.species-in-pieces.com/\n- 图片立体像素画：https://pissang.github.io/voxelize-image/\n- 福利单词（一个不太正经的背单词网站）：http://dict.ftqq.com\n- 查无此人（刷新网站，展现一张 AI 生成的人脸照片）：https://thispersondoesnotexist.com/\n- 在线制作地图图例：https://mapchart.net/\n- 创意光线绘画：http://weavesilk.com/\n- 星系观察：https://stellarium-web.org/\n- 煎蛋：http://jandan.net/\n- 渣男-说话的艺术：https://lovelive.tools/\n- 全历史：https://www.allhistory.com/\n- iData：https://www.cn-ki.net/\n- 术语在线：http://www.termonline.cn/\n\n## 写代码\n\n- GitHub：https://github.com/\n- 码云：https://gitee.com/\n- 源码之家：https://www.mycodes.net/\n- JSON to Dart：\n- https://javiercbk.github.io/json\\_to\\_dart/\n- Json 在线解析验证：\n- https://www.json.cn/\n- 在线接口测试（Getman）：\n- https://getman.cn/\n\n## 资源搜索\n\n- DogeDoge 搜索引擎：www.dogedoge.com\n- 秘迹搜索：https://mijisou.com/\n- 小白盘：https://www.xiaobaipan.com/\n- 云盘精灵（资源搜索）：\n- www.yunpanjingling.com\n- 虫部落（资源搜索）：\n- www.chongbuluo.com\n- 如风搜（资源搜索）：\n- http://www.rufengso.net/\n- 爱扒：https://www.zyboe.com/\n\n## 小工具\n\n- 奶牛快传（在线传输文件利器）：cowtransfer.com\n- 文叔叔（大文件传输，不限速）：\n- https://www.wenshushu.cn/\n- 云端超级应用空间（PS，PPT，Excel，Ai）：https://uzer.me/\n- 香当网（年终总结，个人简历，事迹材料，租赁合同，演讲稿）：\n- https://www.xiangdang.net/\n- 二维码生成：https://cli.im/\n- 搜狗翻译：fanyi.sogou.com\n- 熵数（图表制作，数据可视化）：\n- https://dydata.io/appv2/#/pages/index/home\n- 拷贝兔：https://cp.anyknew.com/\n- 图片无限变放大：http://bigjpg.com/zh\n- 幕布（在线大纲笔记工具）：mubu.com\n- 在线转换器（在线转换器转换任何测量单位）：https://zh.justcnw.com/\n- 调查问卷制作：\n- https://www.wenjuan.com/\n- 果核剥壳（软件下载）：\n- https://www.ghpym.com/\n- 软件下载：https://www.unyoo.com/\n- MSDN 我告诉你（windows10 系统镜像下载）：https://msdn.itellyou.cn/\n\n## 导航页（工具集）\n\n- 世界各国网址大全：http://www.world68.com/\n- 小森林导航：http://www.xsldh6.com/\n- 简捷工具：http://www.shulijp.com/\n- NiceTool.net 好工具网：http://www.nicetool.net/\n- 现实君工具箱（综合型在线工具集成网站）：http://tool.uixsj.cn/\n- 蓝调网站：http://lcoc.top/\n- 偷渡鱼：https://touduyu.com/\n- 牛导航：http://www.ziliao6.com/\n- 小呆导航：https://www.webjike.com/index.html\n- 简法主页：http://www.jianfast.com/\n- KIM 主页：https://kim.plopco.com/\n- 聚 BT：https://jubt.net/cn/index.html\n- 精准云工具合集：https://jingzhunyun.com/\n- 兔 2 工具合集：https://www.tool2.cn/\n- 爱资料工具（在线实用工具集合）：www.toolnb.com\n- 工具导航：https://hao.logosc.cn/\n\n## 看视频\n\n- 阿木影视：https://www.aosk.online/\n- 电影推荐（分类别致）：http://www.mvcat.com\n- APP 影院：https://app.movie\n- 去看 TV：https://www.qukantv.net/\n- 动漫视频网：http://www.zzzfun.com/\n- 94 神马电影网：http://www.9rmb.com/\n- NO 视频官网：http://www.novipnoad.com/\n- 蓝光画质电影：http://www.languang.co/\n- 在线看剧：http://dy.27234.cn/\n- 大数据导航：http://hao.199it.com/\n- 多功能图片网站：https://www.logosc.cn/so/\n- 牛牛 TV：http://www.ziliao6.com/tv/\n- VideoFk 解析视频：http://www.videofk.com/\n- 蓝调网站：http://lcoc.top/vip2.3/\n- 永久资源采集网：http://www.yongjiuzy1.com/\n\n## 学设计\n\n- 码力全开（产品/设计师/独立开发者的资源库）：https://www.maliquankai.com/designnav/\n- 免费音频素材：https://icons8.cn/music\n- 新 CG 儿（视频素材模板，无水印+免费下载）：https://www.newcger.com/\n- Iconfont（阿里巴巴矢量图标库）：https://www.iconfont.cn/\n- 小图标下载：https://www.easyicon.net/\n- Flight Icon：https://www.flighticon.co/\n- 第一字体转换器：http://www.diyiziti.com/\n- doyoudosh（平面设计）：www.doyoudo.com\n- 企业宣传视频在线制作：https://duomu.tv/\n- MAKE 海报设计官网：http://maka.im/\n- 一键海报神器：https://www.logosc.cn/photo/utm\\_source=hao.logosc.cn&utm\\_medium=referral\n- 字由（字体设计）：http://www.hellofont.cn/\n- 查字体网站：https://fonts.safe.360.cn/\n- 爱给网（免费素材下载的网站，包括音效、配乐，3D、视频、游戏，平面、教程）：http://www.aigei.com/\n- 在线视频剪辑：https://bilibili.clipchamp.com/editor\n\n## 搞文档\n\n- 即书（在线制作 PPT）：https://www.keysuper.com/\n- PDF 处理：https://smallpdf.com/cn\n- PDF 处理：https://www.ilovepdf.com/zh-cn\n- PDF 处理：https://www.pdfpai.com/\n- PDF 处理：https://www.hipdf.cn/\n- 图片压缩，PDF 处理：https://docsmall.com/\n- 腾讯文档（在线协作编辑和管理文档）：docs.qq.com\n- ProcessOn（在线协作制作结构图）：www.processon.com\n- iLovePDF（在线转换 PDF 利器）：www.ilovepdf.com\n- PPT 在线制作：https://www.woodo.cn/\n- PDF24 工具（pdf 处理工具）：https://tools.pdf24.org/en\n- IMGBOT（在线图片处理）：www.imgbot.ai\n- 福昕云编辑（在线编辑 PDF）：edit.foxitcloud.cn\n- TinyPNG（在线压缩图片）：tinypng.com\n- UZER.ME（在线使用各种大应用，在线使用 CAD，MATLAB，Office 三件套 ）：uzer.me\n- 优品 PPT（模板下载）：http://www.ypppt.com/\n- 第一 PPT（模板下载）：http://www.1ppt.com/xiazai/\n- 三顿 PPT 导航：sandunppt.com\n- Excel 函数表：https://support.office.com/zh-cn/article/excel-%E5%87%BD%E6%95%B0%EF%BC%88%E6%8C%89%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%EF%BC%89-b3944572-255d-4efb-bb96-c6d90033e188\n\n## 找图片\n\n- 电脑壁纸：http://lcoc.top/bizhi/\n- https://unsplash.com/\n- https://pixabay.com/\n- https://www.pexels.com/\n- https://visualhunt.com/\n- https://www.ssyer.com/\n- 彼岸图网：http://pic.netbian.com/\n- 极像素（超高清大图）：https://www.sigoo.com/\n- 免费版权图片搜索：https://www.logosc.cn/so/\n","tags":[{"name":"网站","slug":"网站","permalink":"https://xuyuquan0713.github.io/tags/%E7%BD%91%E7%AB%99/"}]},{"title":"MATLAB中的函数学习","date":"2021-03-12T06:56:37.000Z","path":"2021/03/12/我的博客创建/","text":"遇到的 matlab 函数的小计，持续增加 rand 函数指定区域内的随机数一般来说，可以使用公式 r = a + (b-a).*rand(N,1) 生成区间 (a,b) 内的 N 个随机数。 &gt;&gt; r &#x3D; -5 + (5+5)*rand(10,1) %生成一个由区间 (-5,5) 内均匀分布的数字组成的 10×1 列向量。 r &#x3D; -0.6126 -1.1844 2.6552 2.9520 -3.1313 -0.1024 -0.5441 1.4631 2.0936 2.5469","raw":"---\ntitle: MATLAB中的函数学习\ndate: 2021-03-12 14:56:37\ntags:\n---\n\n---\n\n遇到的 matlab 函数的小计，持续增加\n\n---\n\n<!--more-->\n\n# rand 函数指定区域内的随机数\n\n一般来说，可以使用公式 r = a + (b-a).\\*rand(N,1) 生成区间 (a,b) 内的 N 个随机数。\n\n```test\n>> r = -5 + (5+5)*rand(10,1)     %生成一个由区间 (-5,5) 内均匀分布的数字组成的 10×1 列向量。\n\nr =\n\n   -0.6126\n   -1.1844\n    2.6552\n    2.9520\n   -3.1313\n   -0.1024\n   -0.5441\n    1.4631\n    2.0936\n    2.5469\n```\n","tags":[]},{"title":"Hello World","date":"2021-03-11T06:56:37.000Z","path":"2021/03/11/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment 上传到git上和gitee上备份博客 git add . git commit -m &quot;xxxx&quot; 上传到hexo分支 git push -u origin hexo git push -u gitee hexo","raw":"---\ntitle: Hello World\ndate: 2021-03-11 14:56:37\ntags: tags\n---\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n```bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n```bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n```bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n```bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n```\n上传到git上和gitee上备份博客\ngit add .\ngit commit -m \"xxxx\"\n上传到hexo分支\ngit push -u origin hexo\ngit push -u gitee hexo\n\n```\n\n","tags":[{"name":"tags","slug":"tags","permalink":"https://xuyuquan0713.github.io/tags/tags/"}]}]